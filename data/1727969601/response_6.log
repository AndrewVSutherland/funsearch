def priority_v1(k: int, n: int) -> float:
    """Improved version of `priority_v0`."""
    if k == 0:
        return 0.0
    return 1.0 / np.log2(1 + k / n)

def find_large_ss_progressions(n: int, size: int) -> list[tuple[int, ...]]:
    """Finds large Salem-Spencer progressions.

    Args:
        n: The number of possible integers.
        size: The size of the progressions to find.

    Returns:
        A list of large Salem-Spencer progressions.
    """
    progressions = []
    for k in range(n):
        priority = priority_v1(k, n)
        if priority > 0.5:  # Only consider integers with high priority.
            for progression in itertools.combinations_with_replacement(range(n), size):
                if all(priority_v1(p, n) > 0.5 for p in progression):
                    progressions.append(progression)
    return progressions