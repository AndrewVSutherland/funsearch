def priority_v2(k: int, n: int) -> float:
    """Improved version of `priority_v1`."""
    # We want to prioritize numbers that are close to the center of the range
    # and have a high density of numbers around them.
    # The formula below calculates the distance of the number from the center
    # and subtracts it from the count of numbers in a range around it.
    # The higher the result, the higher the priority.
    center = n // 2
    range_size = n // 10  # adjust this value to change the range size
    return np.count_nonzero((center - range_size < np.arange(n)) & (np.arange(n) < center + range_size)) - abs(k - center)

def find_large_ss_progressions(n: int, size: int, min_value: int = 0):
    """Finds large Salem-Spencer sets with given size and minimum value."""
    # Generate all possible sets of size `size` from the range `min_value` to `n`
    all_sets = set(itertools.combinations(range(min_value, n), size))

    # Sort the sets by priority
    sorted_sets = sorted(all_sets, key=lambda s: sum(priority_v2(k, n) for k in s), reverse=True)

    # Iterate over the sorted sets
    for ss in sorted_sets:
        # Check if the set is a Salem-Spencer set
        if is_salem_spencer_set(ss):
            return ss

    return None

def is_salem_spencer_set(ss):
    """Checks if a set is a Salem-Spencer set."""
    # A set is a Salem-Spencer set if for any two elements a and b in the set,
    # the difference between a and b is also in the set.
    for a, b in itertools.combinations(ss, 2):
        if abs(a - b) not in ss:
            return False
    return True