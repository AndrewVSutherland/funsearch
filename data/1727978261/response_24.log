def priority_v1(el: tuple[int, ...], n: int) -> float:
  # Count the number of 2's in the tuple
  count_2 = el.count(2)

  # Count the number of 1's in the tuple
  count_1 = el.count(1)

  # The priority is the square of the number of 2's plus the number of 1's
  return count_2**2 + count_1


@funsearch.run
def priority_v2(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v1`."""

  # Count the number of 2's in the tuple
  count_2 = el.count(2)

  # Count the number of 1's in the tuple
  count_1 = el.count(1)

  # Calculate the sum of squares of indices of 2's
  sum_sq_indices_2 = sum([i**2 for i, x in enumerate(el) if x == 2])

  # The priority is the square of the number of 2's plus the number of 1's minus the sum of squares of indices of 2's
  return count_2**2 + count_1 - sum_sq_indices_2


def find_cap_sets(n: int) -> tuple[list[tuple[int, ...]], float]:
  """Returns the cap set and its total priority."""
  cap_set = []
  total_priority = 0.0

  # Generate all possible tuples of length n with values 0-2
  for el in itertools.product(range(3), repeat=n):
    # If the sum of the tuple is less than or equal to n, add it to the cap set
    if sum(el) <= n:
      cap_set.append(el)
      total_priority += priority_v2(el, n)

  return cap_set, total_priority