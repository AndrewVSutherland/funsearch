# Count the number of 1s and 2s in the tuple
  num_ones = el.count(1)
  num_twos = el.count(2)

  # Give higher priority to tuples with more 1s and fewer 2s
  return num_ones - 0.5 * num_twos


def priority_v2(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v1`.
  Prioritizes tuples with a balanced distribution of 1s and 2s, as these are more likely to contribute to a large cap set.
  """
  # Count the number of 1s, 2s, and 0s in the tuple
  num_ones = el.count(1)
  num_twos = el.count(2)
  num_zeros = n - num_ones - num_twos

  # Calculate the variance of the distribution of 1s and 2s
  variance = np.var([num_ones, num_twos])

  # Give higher priority to tuples with a lower variance and more 1s
  return num_ones - variance


def priority_v3(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v2`.
  Prioritizes tuples with a balanced distribution of 1s, 2s, and 0s, as these are more likely to contribute to a large cap set.
  """
  # Count the number of 1s, 2s, and 0s in the tuple
  num_ones = el.count(1)
  num_twos = el.count(2)
  num_zeros = n - num_ones - num_twos

  # Calculate the variance of the distribution of 1s, 2s, and 0s
  variance = np.var([num_ones, num_twos, num_zeros])

  # Give higher priority to tuples with a lower variance and more 1s
  return num_ones - variance