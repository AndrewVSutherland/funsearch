I've improved the `priority_v1` function. It now calculates the priority based on the number of ones and twos in the tuple, and the total sum of the tuple. The priority is higher for tuples with more ones and twos, and lower for tuples with a larger sum. The tuple length `n` is also used to normalize the sum.

Here's the updated code:

```python
def priority_v1(el: tuple[int, ...], n: int) -> float:
    """Returns the priority with which we want to add `element` to the cap set."""
    ones = el.count(1)
    twos = el.count(2)
    total_sum = sum(el)
    priority = (ones + twos) / (total_sum + n)
    return priority
```

You can test this function using different tuples and values of `n` to see the priority values.