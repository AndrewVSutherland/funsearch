def priority_v1(el: tuple[int, ...], n: int) -> float:
    """Improved version of `priority_v0`.

    The priority is calculated as a weighted sum of the elements in the tuple.
    The weight of each element is 3^(n-i), where i is the index of the element.
    This way, the most significant bit is given the most weight.
    """
    return sum(weight * value for weight, value in zip([3**i for i in range(n-1, -1, -1)], el))


@funsearch.run
def priority_v2(el: tuple[int, ...], n: int) -> float:
    """Improved version of `priority_v1`.

    Instead of calculating the priority as a weighted sum, we calculate it as the sum of the bases.
    The base of each element is 3^(n-i) if the value of the element is 1, or 0 otherwise.
    This way, we only consider the elements that have a value of 1.
    """
    return sum(3**(n-i) for i, value in enumerate(el) if value == 1)


@funsearch.run
def priority_v3(el: tuple[int, ...], n: int) -> float:
    """Improved version of `priority_v2`.

    Instead of calculating the priority for each element individually, we calculate it for the entire tuple.
    The priority is calculated as the number represented by the tuple in base 3.
    """
    return int(''.join(map(str, el)), 3)


@funsearch.run
def priority_v4(el: tuple[int, ...], n: int) -> float:
    """Improved version of `priority_v3`.

    We use numpy to calculate the priority. This allows us to use vectorized operations, which are faster than regular Python operations.
    """
    return np.dot(el, 3**np.arange(n-1, -1, -1))


@funsearch.run
def priority_v5(el: tuple[int, ...], n: int) -> float:
    """Improved version of `priority_v4`.

    We use numpy's base conversion functions to calculate the priority. This is faster than calculating it manually.
    """
    return int(np.base_repr(int(''.join(map(str, el)), 2), base=3))


def main():
    n = 10
    cap_sets = []
    elements = itertools.product(range(3), repeat=n)
    for element in elements:
        priority = priority_v5(element, n)
        if priority > 0:
            cap_sets.append((element, priority))
    # Sort the cap sets by priority in descending order.
    cap_sets.sort(key=lambda x: x[1], reverse=True)
    for cap_set, priority in cap_sets:
        print(f'{cap_set} {priority}')


if __name__ == '__main__':
    main()