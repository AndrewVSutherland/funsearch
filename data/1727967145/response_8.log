Here's an improved version of `priority_v1` with small changes to make the code shorter and more efficient. I've used numpy for vectorized operations and removed the unnecessary `range(1, n + 1)` in the multiples calculation.

```python
import numpy as np

def priority_v2(k: int, n: int) -> float:
    """Improved version of `priority_v1`."""
    remainders = np.unique((k * np.arange(1, n + 1)) % n)
    multiples = np.count_nonzero((k * np.arange(1, n + 1)) % n == 0)
    return len(remainders) / n + multiples / n
```

This version of the function performs the same calculations as `priority_v1` but in a more concise and efficient way. The use of numpy's `unique` function to find the remainders and `count_nonzero` to count the multiples significantly reduces the number of lines of code and improves performance.