Here's an improved version of `priority_v1` with some small changes to make it more efficient and concise. I've used `np.unique` to find the unique remainders and removed the unnecessary `sum` for multiples.

```python
import numpy as np

def priority_v2(k: int, n: int) -> float:
    """Improved version of `priority_v1`."""
    remainders = np.unique((k * np.arange(1, n + 1)) % n)
    return len(remainders) / n + np.count_nonzero((k * np.arange(1, n + 1)) % n == 0) / n
```

This version of the function performs the same calculations as `priority_v1` but in a more efficient manner by using NumPy functions. It also removes the unnecessary creation of a `set` and a `sum` loop, making the code shorter and more readable.