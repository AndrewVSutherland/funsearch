Here's an improved version of `priority_v1` that considers the number of unique remainders when dividing `k` by `n`, as well as the number of multiples of `k` less than `n`. This version is shorter and makes small changes to improve the priority function.

```python
def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  unique_remainders = len(set(k % i for i in range(1, n + 1)))
  multiples_of_k = sum(i % k == 0 for i in range(1, n + 1))
  return unique_remainders * multiples_of_k
```

This version uses the `set` data structure to count the number of unique remainders, and a generator expression with the `sum` function to count the number of multiples of `k`. The priority is then calculated as the product of these two values.