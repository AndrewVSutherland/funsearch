def priority_v1(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v0`.

  Priority is calculated as the sum of the elements in the tuple,
  with each element weighted by its position in the tuple.
  The weight is calculated as 2^(n-i), where i is the position of the element.
  """
  return sum(val * 2**(n - i) for i, val in enumerate(el))


@funsearch.run
def priority_v2(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v1`.

  Priority is calculated as the sum of the elements in the tuple,
  with each element weighted by its position in the tuple.
  The weight is calculated as 2^(n-i), where i is the position of the element.
  The priority is also adjusted based on the number of 1s in the tuple.
  """
  ones = sum(1 for val in el if val == 1)
  return sum(val * 2**(n - i) for i, val in enumerate(el)) + ones * 0.5


@funsearch.run
def priority_v3(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v2`.

  Priority is calculated as the sum of the elements in the tuple,
  with each element weighted by its position in the tuple.
  The weight is calculated as 2^(n-i), where i is the position of the element.
  The priority is also adjusted based on the number of 1s in the tuple and the number of 2s in the tuple.
  """
  ones = sum(1 for val in el if val == 1)
  twos = sum(1 for val in el if val == 2)
  return sum(val * 2**(n - i) for i, val in enumerate(el)) + ones * 0.5 + twos * 0.25


def generate_cap_set(n: int, k: int, priority_fn: callable) -> set[tuple[int, ...]]:
  """Generates a cap set of size k for the vector space of dimension n.

  The cap set is generated by iteratively adding the element with the highest priority
  that is not already in the cap set.
  """
  cap_set = set()
  for el in itertools.product(range(3), repeat=n):
    if len(cap_set) == k:
      break
    if el not in cap_set and all(sum(np.bitwise_and(el, other)) < 2 for other in cap_set):
      cap_set.add(el)
      cap_set = {el for el in cap_set if priority_fn(el, n) >= priority_fn(min(cap_set, key=lambda x: priority_fn(x, n)), n)}
  return cap_set


# Example usage:
n = 5
k = 3
cap_set = generate_cap_set(n, k, priority_v3)
print(cap_set)