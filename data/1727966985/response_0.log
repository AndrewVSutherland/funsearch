def priority_v1(k: int, n: int) -> float:
    return k / n

@funsearch.run
def priority_v2(k: int, n: int, ss_set: set) -> float:
    """Improved version of `priority_v1`, considers the existing set"""
    return (k / n) * (1 - len(ss_set) / n)

@funsearch.run
def priority_v3(k: int, n: int, ss_set: set) -> float:
    """Considers the progression of the set"""
    max_progression = max([j - i for i, j in itertools.combinations(ss_set, 2)] or [0])
    return (k / n) * (1 - len(ss_set) / n) * (1 - k / max_progression if max_progression else 1)

@funsearch.run
def priority_v4(k: int, n: int, ss_set: set) -> float:
    """Considers the gaps in the set"""
    gaps = sorted([j - i for i, j in itertools.combinations(range(n + 1), 2) if i not in ss_set and j not in ss_set])
    return (k / n) * (1 - len(ss_set) / n) * (1 - k / gaps[0] if gaps else 1)

def ss_progression(n: int, size: int) -> set:
    """Finds the Salem-Spencer set of a given size"""
    ss_set = set()
    while len(ss_set) < size:
        priorities = [priority_v4(k, n, ss_set) for k in range(1, n + 1) if k not in ss_set]
        ss_set.add(np.argmax(priorities) + 1)
    return ss_set

print(ss_progression(100, 10))