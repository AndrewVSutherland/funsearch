Here's an improved version of `priority_v1` that considers the number of unique remainders when dividing `k` by `n`, as well as the sum of digits of `k`. This version is shorter and makes small changes to `priority_v0`.

```python
def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  remainders = set(k % i for i in range(1, n+1))
  return len(remainders) + sum(int(digit) for digit in str(k))
```

In this version, `len(remainders)` gives the number of unique remainders, which is a measure of how many different ways `k` can be combined with other elements to form a complete residue system modulo `n`. The sum of digits of `k` is also added to the priority, as it gives a simple way to prefer larger numbers.

Here's a possible `priority_v2` that makes a small change to `priority_v1` by also considering the number of divisors of `k`:

```python
def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  remainders = set(k % i for i in range(1, n+1))
  num_divisors = len([i for i in range(1, k+1) if k % i == 0])
  return len(remainders) + sum(int(digit) for digit in str(k)) + num_divisors
```

In this version, `num_divisors` gives the number of divisors of `k`, which is a measure of how many different ways `k` can be expressed as a product of smaller numbers. Adding this to the priority encourages preferring numbers with more divisors.