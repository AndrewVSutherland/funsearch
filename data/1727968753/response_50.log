Here's an improved version of `priority_v1` and `priority_v2` based on your instructions. I've made small changes to incorporate exponential decay and considered the growth rate over the last two steps instead of just one. I've also made the code shorter where possible.

```python
import numpy as np

@funsearch.run
def priority_v1(k: int, n: int) -> float:
    """Improved version of `priority_v0` with exponential decay for growth rate."""
    frequency = sum(1 for i in range(n) if i == k)
    growth_rate = (frequency - sum(1 for i in range(k) if i == k - 1) - sum(1 for i in range(k) if i == k - 2)) / (k - (k - 2))
    decay_factor = 0.9  # You can adjust this value to control the decay rate
    return frequency / n + decay_factor * growth_rate

def priority_v2(k: int, n: int) -> float:
    """Improved version of `priority_v1` with a smoother decay factor."""
    frequency = sum(1 for i in range(n) if i == k)
    growth_rate = (frequency - sum(1 for i in range(k) if i == k - 1) - sum(1 for i in range(k) if i == k - 2)) / (k - (k - 2))
    decay_factor = 0.9 ** (k - (k - 2))  # Smoother decay factor
    return frequency / n + decay_factor * growth_rate
```

In `priority_v2`, I've made the decay factor smoother by raising it to the power of the number of steps considered for growth rate calculation. This makes the decay factor decrease more gradually as `k` increases.