Here's an improved version of `priority_v1` that makes small changes to `priority_v0` to improve its performance and code brevity. I've used `np.unique` to count frequencies and removed the list comprehension for remainders calculation.

```python
import numpy as np

def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  remainders = np.arange(n) + k
  remainders %= n
  frequencies, _ = np.unique(remainders, return_counts=True)
  return np.mean(frequencies)
```

This version of `priority_v1` should perform better than `priority_v0` due to the use of NumPy functions, which are optimized for performance. It also reduces the amount of code by removing the list comprehension and using `np.unique` to count frequencies.