Here's an improved version of `priority_v2` with a small change to make it more efficient by using numpy's vectorized operations:

```python
import numpy as np

def priority_v2(k: int, n: int) -> float:
    """Improved version of `priority_v1`."""
    # Create an array of numbers from 0 to n-1
    nums = np.arange(n)

    # Calculate the frequency of multiples of k in the range [0, n)
    freq = np.count_nonzero(nums % k == 0)

    # Calculate the priority
    return freq / n + (n // k) / n
```

This version creates an array of numbers from 0 to `n-1` using `numpy.arange(n)`, which is more efficient than using a for loop. It then uses `numpy.count_nonzero()` to count the number of multiples of `k` in the range `[0, n)`, and finally calculates the priority as before.