Here's an improved version of `priority_v1` that reduces the number of remainders calculated and uses a list to store them, making it more efficient:

```python
def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  remainders = [k % n]
  for i in range(1, n):
    next_remainder = (k + i) % n
    if next_remainder not in remainders:
      remainders.append(next_remainder)
  return len(remainders) / n
```

To further improve the function, we can use a set to store the remainders, which allows for constant time lookups and eliminates duplicates. We can also use the `itertools.cycle` function to generate the sequence of integers, making the code more concise:

```python
def priority_v2(k: int, n: int) -> float:
  """Further improved version of `priority_v1`."""
  remainders = set()
  for i in itertools.cycle(range(n)):
    k = (k + i) % n
    if k not in remainders:
      remainders.add(k)
      if len(remainders) == n:
        break
  return len(remainders) / n
```

This version of the function should provide a better performance improvement while keeping the code short.