Sure, let's start by implementing a simple and efficient algorithm to check if a number is a prime number. Then we can use this function to evaluate the priority of each number based on its primality. Here's the improved version of `priority_v1`:

```python
import numpy as np

def is_prime(n):
    """Returns True if n is a prime number."""
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    sqrt_n = int(np.floor(np.sqrt(n)))
    for i in range(3, sqrt_n + 1, 2):
        if n % i == 0:
            return False
    return True

def priority_v1(k: int, n: int) -> float:
    """Improved version of `priority_v0`. Higher priority is given to prime numbers."""
    if is_prime(k):
        return 1.0 / k  # the smaller the prime, the higher the priority
    else:
        return 0.0
```

In this function, higher priority is given to prime numbers, with smaller prime numbers having a higher priority. This is because smaller prime numbers often lead to larger SS progressions. If `k` is not a prime number, the function returns 0.0, indicating that `k` should not be added to the Salem-Spencer set.