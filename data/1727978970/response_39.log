"""Improved version of `priority_v0`.
The priority is calculated as the total count of 1s multiplied by 0.1 and added to the total count of 2s.
Additionally, it subtracts the count of 0s from the priority.
This change ensures that elements with more 1s and 2s and fewer 0s are prioritized.
"""
count_1 = el.count(1)
count_2 = el.count(2)
count_0 = el.count(0)
return count_1 * 0.1 + count_2 - count_0


@funsearch.run
def search(n: int, k: int) -> set[tuple[int, ...]]:
  """Searches for large cap sets.
  Returns the largest cap-k sets for a cap-k array of length `n`.
  """
  """Improved version of `search`.
  Added a new parameter `max_sets` which specifies the maximum number of sets to return.
  Modified the code to exit the search early if the required number of sets is found.
  """
  def is_good(cap_set: set[tuple[int, ...]]) -> bool:
    array = np.zeros(n, dtype=np.int32)
    for i, j in itertools.product(range(n), repeat=2):
      array[i] += cap_set_array[i, j]
    return np.max(array) <= k

  cap_set_array = np.random.randint(0, 3, size=(n, n))
  cap_set = set()
  elements = [el for el in itertools.product(range(3), repeat=n) if sum(el) == k]
  elements.sort(key=funsearch.compare(priority_v1, n), reverse=True)

  max_sets = 10  # Maximum number of sets to return
  found_sets = 0  # Number of sets found

  for el in elements:
    if found_sets >= max_sets:
      break
    if el not in cap_set and is_good(cap_set | {el}):
      cap_set.add(el)
      found_sets += 1

  return cap_set