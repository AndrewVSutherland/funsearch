def priority_v1(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v0`.

  A simple improvement could be to prioritize elements that have more 2's over elements that have more 0's.
  This is because 2 is the largest number in our set, and we want as many large numbers as possible.
  """
  return el.count(2)


def priority_v2(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v1`.

  Another simple improvement could be to prioritize elements that have more unique numbers over elements that have fewer.
  This is because we want a diverse set of numbers, and having unique numbers increases the diversity of our set.
  """
  return el.count(2) + len(set(el))


def priority_v3(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v2`.

  A more complex improvement could be to prioritize elements that have a higher sum over elements that have a lower sum.
  However, we also want to prioritize diversity, so we can't just return the sum of the elements.
  Instead, we can return the sum of the elements divided by the number of unique elements.
  This gives us a measure of both the size and diversity of the elements.
  """
  return sum(el) / len(set(el))


def priority_v4(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v3`.

  Another improvement could be to prioritize elements that have a lower standard deviation over elements that have a higher standard deviation.
  This is because a lower standard deviation means that the elements are more similar to each other, which increases the chances of finding a cap set.
  """
  return sum(el) / len(set(el)) / np.std(el)