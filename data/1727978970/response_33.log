def priority_v1(el: tuple[int, ...], n: int) -> float:
    """Improved version of `priority_v0`."""
    # Count the number of 0's, 1's, and 2's in el
    count_0 = el.count(0)
    count_1 = el.count(1)
    count_2 = el.count(2)

    # Calculate the priority based on the counts
    # Prioritize elements with more 2's, then more 1's, then more 0's
    priority = count_2 + 0.5 * count_1 + 0.25 * count_0
    return priority


@funsearch.run
def priority_v2(el: tuple[int, ...], n: int) -> float:
    """Improved version of `priority_v1`."""
    # Convert el to a numpy array for easier calculations
    el_array = np.array(el)

    # Calculate the priority based on the sum and standard deviation of el_array
    # Prioritize elements with a higher sum and lower standard deviation
    priority = np.sum(el_array) - np.std(el_array)
    return priority


def priority_v3(el: tuple[int, ...], n: int) -> float:
    """Improved version of `priority_v2`."""
    # Convert el to a numpy array for easier calculations
    el_array = np.array(el)

    # Calculate the priority based on the sum and variance of el_array
    # Prioritize elements with a higher sum and lower variance
    priority = np.sum(el_array) - np.var(el_array)
    return priority


# ... continue this pattern for further improvements


def large_cap_sets(n: int, k: int, m: int) -> list[tuple[int, ...]]:
    """Returns a list of large cap sets.

    A large cap set is a subset of {0, 1, ..., n-1} of size k such that for every
    subset S of {0, 1, ..., n-1} of size m, the number of elements of S in the cap set
    is at most |S|/2.

    The elements in the cap set are selected based on their priority.
    """
    # Generate all subsets of {0, 1, ..., n-1} of size k
    subsets = list(itertools.combinations(range(n), k))

    # Sort the subsets based on their priority
    subsets.sort(key=lambda x: priority_v3(x, n), reverse=True)

    # Select the subsets with the highest priority until a large cap set is found
    for subset in subsets:
        # Check if the subset is a large cap set
        is_large_cap_set = True
        for S in itertools.combinations(range(n), m):
            if sum(1 for e in S if e in subset) > len(S) / 2:
                is_large_cap_set = False
                break

        # If the subset is a large cap set, return it
        if is_large_cap_set:
            return list(subset)

    # If no large cap set is found, return an empty list
    return []