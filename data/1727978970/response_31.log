"""Improved version of `priority_v0`. Returns the priority based on the count of 1's and 2's in the tuple,
  and also considers the count of 0's. It also includes a penalty for having a large number of 2's or 1's,
  and a bonus for having a large number of 0's.
  """
  count_2 = el.count(2)
  count_1 = el.count(1)
  count_0 = el.count(0)
  penalty_2 = 0.1 * count_2 if count_2 > n // 2 else 0
  penalty_1 = 0.05 * count_1 if count_1 > n // 3 else 0
  bonus_0 = 0.2 * count_0 if count_0 > n // 3 else 0
  return count_2 - 0.5 * count_1 + 0.25 * count_0 - penalty_2 - penalty_1 + bonus_0


@funsearch.run
def priority_v2(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v1`.
  Instead of using a fixed penalty for having a large number of 2's or 1's,
  it uses a linear penalty that increases with the number of 2's or 1's.
  """
  count_2 = el.count(2)
  count_1 = el.count(1)
  count_0 = el.count(0)
  penalty_2 = 0.1 * count_2 * (count_2 - n // 2) if count_2 > n // 2 else 0
  penalty_1 = 0.05 * count_1 * (count_1 - n // 3) if count_1 > n // 3 else 0
  bonus_0 = 0.2 * count_0 if count_0 > n // 3 else 0
  return count_2 - 0.5 * count_1 + 0.25 * count_0 - penalty_2 - penalty_1 + bonus_0


@funsearch.run
def priority_v3(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v2`.
  Instead of using a linear penalty for having a large number of 2's or 1's,
  it uses a quadratic penalty that increases more rapidly with the number of 2's or 1's.
  """
  count_2 = el.count(2)
  count_1 = el.count(1)
  count_0 = el.count(0)
  penalty_2 = 0.1 * count_2**2 if count_2 > n // 2 else 0
  penalty_1 = 0.05 * count_1**2 if count_1 > n // 3 else 0
  bonus_0 = 0.2 * count_0 if count_0 > n // 3 else 0
  return count_2 - 0.5 * count_1 + 0.25 * count_0 - penalty_2 - penalty_1 + bonus_0


@funsearch.run
def priority_v4(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v3`.
  Instead of using a penalty for having a large number of 2's or 1's,
  it uses a reward for having a small number of 2's or 1's.
  """
  count_2 = el.count(2)
  count_1 = el.count(1)
  count_0 = el.count(0)
  reward_2 = 0.1 * (n // 2 - count_2) if count_2 < n // 2 else 0
  reward_1 = 0.05 * (n // 3 - count_1) if count_1 < n // 3 else 0
  bonus_0 = 0.2 * count_0 if count_0 > n // 3 else 0
  return count_2 - 0.5 * count_1 + 0.25 * count_0 + reward_2 + reward_1 + bonus_0


@funsearch.run
def priority_v5(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v4`.
  Instead of using a reward for having a small number of 2's or 1's,
  it uses a combination of a reward and a penalty based on the difference between the actual count and the desired count.
  """
  count_2 = el.count(2)
  count_1 = el.count(1)
  count_0 = el.count(0)
  diff_2 = count_2 - n // 2
  diff_1 = count_1 - n // 3
  reward_penalty_2 = 0.1 * diff_2 if abs(diff_2) < n // 2 else -0.1 * diff_2
  reward_penalty_1 = 0.05 * diff_1 if abs(diff_1) < n // 3 else -0.05 * diff_1
  bonus_0 = 0.2 * count_0 if count_0 > n // 3 else 0
  return count_2 - 0.5 * count_1 + 0.25 * count_0 + reward_penalty_2 + reward_penalty_1 + bonus_0