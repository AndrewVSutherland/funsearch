def priority_v1(el: tuple[int, ...], n: int) -> float:
    # Calculate the number of 2's and 1's in the tuple
    count_2 = el.count(2)
    count_1 = el.count(1)

    # Calculate the priority based on the number of 2's and 1's
    # Prioritize tuples with more 2's and fewer 1's
    priority = count_2 - count_1

    return priority

@funsearch.run
def priority_v2(el: tuple[int, ...], n: int) -> float:
    """Improved version of `priority_v1`."""
    # Calculate the number of 2's and 1's in the tuple
    count_2 = el.count(2)
    count_1 = el.count(1)

    # Calculate the priority based on the number of 2's and 1's
    # Prioritize tuples with more 2's and fewer 1's
    # Add a small penalty for having more 1's to encourage more balanced tuples
    priority = count_2 - 0.5 * count_1

    return priority

@funsearch.run
def priority_v3(el: tuple[int, ...], n: int) -> float:
    """Improved version of `priority_v2`."""
    # Calculate the number of 2's and 1's in the tuple
    count_2 = el.count(2)
    count_1 = el.count(1)

    # Calculate the priority based on the number of 2's and 1's
    # Prioritize tuples with more 2's and fewer 1's
    # Add a small penalty for having more 1's to encourage more balanced tuples
    # Also, add a small bonus for having more 0's to further encourage balanced tuples
    count_0 = el.count(0)
    priority = count_2 - 0.5 * count_1 + 0.2 * count_0

    return priority

def get_cap_sets(n: int) -> list[set[tuple[int, ...]]]:
  """Finds the cap sets."""
  cap_sets = []
  for cap_set in itertools.combinations(range(2**n), n):
    cap_set_array = np.array(list(cap_set))
    cap_set_elements = np.unpackbits(cap_set_array[:, None], axis=1, count=n)
    if not np.all(np.sum(cap_set_elements, axis=0) >= np.sum(cap_set_elements, axis=1)):
      continue
    cap_set = {tuple(el) for el in cap_set_elements}
    cap_sets.append(cap_set)
  return cap_sets


def find_large_cap_sets(n: int) -> list[set[tuple[int, ...]]]:
  """Finds the large cap sets.

  A large cap set is a cap set with size at least n - 1.
  """
  cap_sets = get_cap_sets(n)
  large_cap_sets = [cap_set for cap_set in cap_sets if len(cap_set) >= n - 1]
  return large_cap_sets


def test_find_large_cap_sets():
  """Tests `find_large_cap_sets`."""
  for n in range(2, 6):
    large_cap_sets = find_large_cap_sets(n)
    print(f"n = {n}: {len(large_cap_sets)} large cap sets")
    for cap_set in large_cap_sets:
      print(cap_set)


if __name__ == "__main__":
  test_find_large_cap_sets()