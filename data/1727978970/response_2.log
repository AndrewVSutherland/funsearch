def priority_v1(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v0`.

  The priority is calculated as the sum of the elements in the tuple,
  with the maximum value being 2.
  """
  return sum(el) / (2 * n)


def priority_v2(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v1`.

  The priority is calculated as the sum of the elements in the tuple,
  with the maximum value being 2, plus a bonus for having more 2s in the tuple.
  """
  return (sum(el) + el.count(2) * 0.1) / (2 * n)


def priority_v3(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v2`.

  The priority is calculated as the sum of the elements in the tuple,
  with the maximum value being 2, plus a bonus for having more 2s in the tuple,
  and a penalty for having more 0s in the tuple.
  """
  return (sum(el) + el.count(2) * 0.1 - el.count(0) * 0.1) / (2 * n)


def priority_v4(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v3`.

  The priority is calculated as the sum of the elements in the tuple,
  with the maximum value being 2, plus a bonus for having more 2s in the tuple,
  a penalty for having more 0s in the tuple, and a bonus for having more unique
  elements in the tuple.
  """
  return (sum(el) + el.count(2) * 0.1 - el.count(0) * 0.1 + len(set(el)) * 0.1) / (2 * n)


def priority_v5(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v4`.

  The priority is calculated as the sum of the elements in the tuple,
  with the maximum value being 2, plus a bonus for having more 2s in the tuple,
  a penalty for having more 0s in the tuple, a bonus for having more unique
  elements in the tuple, and a bonus for having a larger product of the elements
  in the tuple.
  """
  return (sum(el) + el.count(2) * 0.1 - el.count(0) * 0.1 + len(set(el)) * 0.1 + np.prod(el) * 0.01) / (2 * n)


def priority_v6(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v5`.

  The priority is calculated as the sum of the elements in the tuple,
  with the maximum value being 2, plus a bonus for having more 2s in the tuple,
  a penalty for having more 0s in the tuple, a bonus for having more unique
  elements in the tuple, a bonus for having a larger product of the elements
  in the tuple, and a penalty for having more consecutive 2s in the tuple.
  """
  return (sum(el) + el.count(2) * 0.1 - el.count(0) * 0.1 + len(set(el)) * 0.1 + np.prod(el) * 0.01 - el.count('22') * 0.1) / (2 * n)


def priority_v7(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v6`.

  The priority is calculated as the sum of the elements in the tuple,
  with the maximum value being 2, plus a bonus for having more 2s in the tuple,
  a penalty for having more 0s in the tuple, a bonus for having more unique
  elements in the tuple, a bonus for having a larger product of the elements
  in the tuple, a penalty for having more consecutive 2s in the tuple, and
  a bonus for having more consecutive 1s in the tuple.
  """
  return (sum(el) + el.count(2) * 0.1 - el.count(0) * 0.1 + len(set(el)) * 0.1 + np.prod(el) * 0.01 - el.count('22') * 0.1 + el.count('11') * 0.1) / (2 * n)


def priority_v8(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v7`.

  The priority is calculated as the sum of the elements in the tuple,
  with the maximum value being 2, plus a bonus for having more 2s in the tuple,
  a penalty for having more 0s in the tuple, a bonus for having more unique
  elements in the tuple, a bonus for having a larger product of the elements
  in the tuple, a penalty for having more consecutive 2s in the tuple, a bonus
  for having more consecutive 1s in the tuple, and a bonus for having more
  consecutive 0s in the tuple.
  """
  return (sum(el) + el.count(2) * 0.1 - el.count(0) * 0.1 + len(set(el)) * 0.1 + np.prod(el) * 0.01 - el.count('22') * 0.1 + el.count('11') * 0.1 + el.count('00') * 0.1) / (2 * n)


def priority_v9(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v8`.

  The priority is calculated as the sum of the elements in the tuple,
  with the maximum value being 2, plus a bonus for having more 2s in the tuple,
  a penalty for having more 0s in the tuple, a bonus for having more unique
  elements in the tuple, a bonus for having a larger product of the elements
  in the tuple, a penalty for having more consecutive 2s in the tuple, a bonus
  for having more consecutive 1s in the tuple, a bonus for having more
  consecutive 0s in the tuple, and a bonus for having a larger sum of the
  indices of the 2s in the tuple.
  """
  return (sum(el) + el.count(2) * 0.1 - el.count(0) * 0.1 + len(set(el)) * 0.1 + np.prod(el) * 0.01 - el.count('22') * 0.1 + el.count('11') * 0.1 + el.count('00') * 0.1 + sum([i for i, x in enumerate(el) if x == 2]) * 0.1) / (2 * n)


def priority_v10(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v9`.

  The priority is calculated as the sum of the elements in the tuple,
  with the maximum value being 2, plus a bonus for having more 2s in the tuple,
  a penalty for having more 0s in the tuple, a bonus for having more unique
  elements in the tuple, a bonus for having a larger product of the elements
  in the tuple, a penalty for having more consecutive 2s in the tuple, a bonus
  for having more consecutive 1s in the tuple, a bonus for having more
  consecutive 0s in the tuple, a bonus for having a larger sum of the
  indices of the 2s in the tuple, and a penalty for having more consecutive 1s
  followed by a 0 in the tuple.
  """
  return (sum(el) + el.count(2) * 0.1 - el.count(0) * 0.1 + len(set(el)) * 0.1 + np.prod(el) * 0.01 - el.count('22') * 0.1 + el.count('11') * 0.1 + el.count('00') * 0.1 + sum([i for i, x in enumerate(el) if x == 2]) * 0.1 - el.count('10') * 0.1) / (2 * n)