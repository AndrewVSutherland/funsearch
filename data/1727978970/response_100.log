To find large cap sets, we can use a greedy algorithm that iteratively adds elements to the set based on a priority score. In each iteration, we select the element with the highest priority score that is not already in the set and does not have any conflicts with the elements already in the set.

Here's an improved version of the `priority_v0` function that calculates the priority score for an element `el`. The priority score is defined as the number of unique values in `el` minus 0.2 times the number of occurrences of the value 2 in `el`.

```python
def priority_v1(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v0`."""
  return len(set(el)) - 0.2 * el.count(2)
```

To implement the greedy algorithm, we can use the `itertools.combinations` function to generate all possible combinations of elements from the given range. We can then sort these combinations based on their priority scores and iteratively add the elements to the cap set.

Here's an implementation of the greedy algorithm using `priority_v1`:

```python
def find_large_cap_sets(n: int, k: int) -> set[tuple[int, ...]]:
  """Finds large cap sets of size `k` using `n` values from the range [0, 2].

  Args:
    n: The number of values to choose from.
    k: The size of the cap sets to find.

  Returns:
    A set of tuples representing the large cap sets.
  """
  # Generate all possible combinations of elements from the range [0, 2]
  combinations = itertools.combinations(range(3), n)

  # Sort the combinations based on their priority scores
  sorted_combinations = sorted(combinations, key=lambda el: priority_v1(el, n), reverse=True)

  # Initialize an empty cap set
  cap_sets = set()

  # Iteratively add elements to the cap set
  for el in sorted_combinations:
    # Check if the element can be added to the cap set
    if len(set(el) & set(itertools.chain.from_iterable(cap_sets))) < k and el not in cap_sets:
      # Add the element to the cap set
      cap_sets.add(el)

  return cap_sets
```

This implementation should be able to find large cap sets more efficiently than the previous version by prioritizing elements with more unique values and fewer occurrences of the value 2.