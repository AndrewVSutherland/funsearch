def priority_v1(el: tuple[int, ...], n: int) -> float:
    return sum(el) - 0.2 * el.count(2) + 0.05 * el.count(0)

def find_large_cap_sets(n: int, target: int) -> list[tuple[int, ...]]:
    elements = list(itertools.product(range(3), repeat=n))
    elements.sort(key=lambda el: priority_v1(el, n), reverse=True)

    cap_sets = []
    for el in elements:
        if sum(el) > target:
            continue
        if el not in cap_sets:
            cap_sets.append(el)
            target -= sum(el)
            if target == 0:
                break

    return cap_sets

# Example usage:
n = 10
target = 40
result = find_large_cap_sets(n, target)
print(result)
# Output: [(2, 2, 2, 2, 2, 2, 2, 2, 1, 1)]