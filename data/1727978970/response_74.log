"""Improved version of `priority_v1`."""
return sum(el) / len(set(el)) * np.exp(-np.std(el))


def cap_sets(n: int, k: int) -> list[tuple[int, ...]]:
  """Returns a list of `k` cap sets of size `n`."""
  cap_sets = []
  for el in itertools.product(range(3), repeat=n):
    if len(set(el)) == n:
      cap_sets.append(el)
    if len(cap_sets) == k:
      break
  return sorted(cap_sets, key=lambda el: priority_v2(el, n), reverse=True)


def main() -> None:
  """The main function."""
  print(cap_sets(5, 10))


if __name__ == "__main__":
  main()


"""
Explanation of the code:

- The `priority_v0` function calculates the priority of adding a cap set `el` to the list of cap sets. It does this by summing the elements of `el`, dividing by the number of unique elements in `el`, and dividing by the standard deviation of `el`.

- The `priority_v1` function is an improved version of `priority_v0` that also takes into account the exponential decay of the standard deviation.

- The `cap_sets` function generates a list of `k` cap sets of size `n`. It does this by iterating over all possible cap sets of size `n` and checking if they are valid (i.e., they contain `n` unique elements). It then sorts the list of cap sets by their priority, as calculated by the `priority_v2` function, and returns the top `k` cap sets.

- The `main` function simply calls the `cap_sets` function with `n=5` and `k=10` and prints the result.
"""