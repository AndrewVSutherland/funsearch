def priority_v2(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v1`.

  Another improvement could be to prioritize elements that have a higher sum over elements that have a lower sum.
  This is because a higher sum means that the elements are more likely to cover all possible combinations, which increases the chances of finding a cap set.
  """
  return sum(el) / len(set(el)) / np.std(el) + sum(el)


def priority_v3(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v2`.

  Another improvement could be to prioritize elements that have a higher number of unique elements over elements that have a lower number of unique elements.
  This is because a higher number of unique elements means that the element covers more possible combinations, which increases the chances of finding a cap set.
  """
  return sum(el) / len(set(el)) / np.std(el) + sum(el) + len(set(el))


def priority_v4(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v3`.

  Another improvement could be to prioritize elements that have a higher number of occurrences of the value 2 over elements that have a lower number of occurrences of the value 2.
  This is because the value 2 indicates that the element covers two possible combinations, which increases the chances of finding a cap set.
  """
  return sum(el) / len(set(el)) / np.std(el) + sum(el) + el.count(2)


def priority_v5(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v4`.

  Another improvement could be to prioritize elements that have a higher number of occurrences of the value 1 over elements that have a lower number of occurrences of the value 1.
  This is because the value 1 indicates that the element covers one possible combination, which increases the chances of finding a cap set.
  """
  return sum(el) / len(set(el)) / np.std(el) + sum(el) + el.count(2) + el.count(1)


def find_cap_sets(n: int, k: int) -> list[tuple[int, ...]]:
  """Returns a list of all cap sets of size `k` in a set of size `n`."""
  return list(itertools.product(range(3), repeat=n))


def find_large_cap_sets(n: int, k: int) -> list[tuple[int, ...]]:
  """Returns a list of all large cap sets of size `k` in a set of size `n`."""
  cap_sets = find_cap_sets(n, k)
  pri_func = priority_v5
  cap_sets.sort(key=lambda x: pri_func(x, n), reverse=True)
  large_cap_sets = []
  for cap_set in cap_sets:
    if all(sum(cap_set[i:j]) <= 1 for i, j in itertools.combinations(range(n+1), 2)):
      large_cap_sets.append(cap_set)
  return large_cap_sets


def main():
  n = 10
  k = 5
  large_cap_sets = find_large_cap_sets(n, k)
  print(f"Found {len(large_cap_sets)} large cap sets of size {k} in a set of size {n}.")


if __name__ == '__main__':
  main()