"""Improved version of `priority_v0`.
The priority is calculated as the total count of 1s multiplied by 0.1,
the total count of 2s multiplied by 0.01, and added to the total count of 0s.
"""
count_0 = el.count(0)
count_1 = el.count(1)
count_2 = el.count(2)
return count_0 + count_1 * 0.1 + count_2 * 0.01


@funsearch.run
def priority_v2(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v1`.
  The priority is calculated as the total count of 1s multiplied by 0.1,
  the total count of 2s multiplied by 0.01, and added to the total count of 0s.
  However, if the total count of 2s is greater than 2, the priority is set to 0.
  """
  count_0 = el.count(0)
  count_1 = el.count(1)
  count_2 = el.count(2)
  if count_2 > 2:
    return 0
  return count_0 + count_1 * 0.1 + count_2 * 0.01


@funsearch.run
def priority_v3(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v2`.
  The priority is calculated as the total count of 1s multiplied by 0.1,
  the total count of 2s multiplied by 0.01, and added to the total count of 0s.
  However, if the total count of 2s is greater than 2 or the total count of 1s is greater than n//2, the priority is set to 0.
  """
  count_0 = el.count(0)
  count_1 = el.count(1)
  count_2 = el.count(2)
  if count_2 > 2 or count_1 > n // 2:
    return 0
  return count_0 + count_1 * 0.1 + count_2 * 0.01


@funsearch.run
def priority_v4(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v3`.
  The priority is calculated as the total count of 1s multiplied by 0.1,
  the total count of 2s multiplied by 0.01, and added to the total count of 0s.
  However, if the total count of 2s is greater than 2, the total count of 1s is greater than n//2,
  or the total count of 0s is less than n//4, the priority is set to 0.
  """
  count_0 = el.count(0)
  count_1 = el.count(1)
  count_2 = el.count(2)
  if count_2 > 2 or count_1 > n // 2 or count_0 < n // 4:
    return 0
  return count_0 + count_1 * 0.1 + count_2 * 0.01


@funsearch.run
def priority_v5(el: tuple[int, ...], n: int) -> float:
  """Improved version of `priority_v4`.
  The priority is calculated as the total count of 1s multiplied by 0.1,
  the total count of 2s multiplied by 0.01, and added to the total count of 0s.
  However, if the total count of 2s is greater than 2, the total count of 1s is greater than n//2,
  or the total count of 0s is less than n//4, the priority is set to 0.
  Additionally, if the total count of 1s is less than n//4, the priority is reduced by 0.05.
  """
  count_0 = el.count(0)
  count_1 = el.count(1)
  count_2 = el.count(2)
  if count_2 > 2 or count_1 > n // 2 or count_0 < n // 4:
    return 0
  priority = count_0 + count_1 * 0.1 + count_2 * 0.01
  if count_1 < n // 4:
    priority -= 0.05
  return priority


def all_elements(n: int) -> list[tuple[int, ...]]:
  """Returns all elements of length n with values 0-2."""
  return list(itertools.product(range(3), repeat=n))


def find_large_cap_sets(n: int):
  """Finds large cap sets."""
  elements = all_elements(n)
  best_priority = float('-inf')
  best_cap_set = []
  for cap_set in itertools.combinations(elements, n):
    priority = sum(priority_v5(el, n) for el in cap_set)
    if priority > best_priority:
      best_priority = priority
      best_cap_set = cap_set
  return best_cap_set


if __name__ == '__main__':
  n = 5
  cap_set = find_large_cap_sets(n)
  print(f'Cap set of size {n}:')
  for el in cap_set:
    print(el)
  print(f'Priority: {priority_v5(cap_set, n)}')