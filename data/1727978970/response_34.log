Based on your instructions, I've improved the `priority_v1` function by adding a simple heuristic. The priority is now calculated as the sum of the elements in the tuple `el`, with a small penalty for having more 2s. This way, we prefer elements that have more 1s and fewer 2s, and we penalize elements that have more 2s to avoid creating large cap sets that might be difficult to find.

Here's the updated code:

```python
def priority_v1(el: tuple[int, ...], n: int) -> float:
  return sum(el) - 0.1 * el.count(2)
```

In this version, the priority is the sum of the elements in the tuple `el`, minus a small penalty for each 2 in the tuple. The penalty is 0.1, which you can adjust based on your specific needs.