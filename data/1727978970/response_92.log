def priority_v2(el: tuple[int, ...], n: int) -> float:
    """Improved version of `priority_v1`."""
    # Weights assigned to each unique value in the tuple
    weights = [1, 0.8, 0.5]
    # Calculate the weighted sum of unique values in the tuple
    weighted_sum = sum(weights[i] for i in set(el))
    # Subtract the count of 2s multiplied by a penalty factor
    penalty = 0.2 * el.count(2)
    return weighted_sum - penalty


def find_large_cap_sets(n: int, k: int, m: int) -> list[tuple[int, ...]]:
    """Finds large cap sets of size `n` with `k` distinct elements and `m` total elements."""
    # Generate all possible tuples of length n with values 0-2
    tuples = itertools.product(range(3), repeat=n)
    # Filter tuples that have k distinct elements and m total elements
    filtered_tuples = [t for t in tuples if len(set(t)) == k and sum(t) == m]
    # Sort tuples by priority and return the top k
    sorted_tuples = sorted(filtered_tuples, key=lambda t: priority_v2(t, n), reverse=True)
    return sorted_tuples[:k]


# Example usage:
n = 5
k = 3
m = 7
large_cap_sets = find_large_cap_sets(n, k, m)
print(large_cap_sets)