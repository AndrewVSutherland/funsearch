"""Improved version of `priority_v1`.

Another improvement could be to prioritize elements that have a lower variance over elements that have a higher variance.
This is because a lower variance means that the elements are more closely grouped around the mean, which increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / np.var(el)


def priority_v3(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v2`."""

"""Another improvement could be to prioritize elements that have a lower coefficient of variation over elements that have a higher coefficient of variation.
This is because a lower coefficient of variation means that the elements are more tightly packed around the mean, which increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el))


def priority_v4(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v3`."""

"""Another improvement could be to prioritize elements that have a higher number of unique values over elements that have a lower number of unique values.
This is because a higher number of unique values increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n


def priority_v5(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v4`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros over elements that have a lower number of zeros.
This is because a higher number of zeros increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n + el.count(0) / n


def priority_v6(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v5`."""

"""Another improvement could be to prioritize elements that have a higher number of ones over elements that have a lower number of ones.
This is because a higher number of ones increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n + el.count(0) / n + el.count(1) / n


def priority_v7(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v6`."""

"""Another improvement could be to prioritize elements that have a higher number of twos over elements that have a lower number of twos.
This is because a higher number of twos increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n + el.count(0) / n + el.count(1) / n + el.count(2) / n


def priority_v8(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v7`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros and ones over elements that have a higher number of twos.
This is because a higher number of zeros and ones increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n + el.count(0) / n + el.count(1) / n - el.count(2) / n


def priority_v9(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v8`."""

"""Another improvement could be to prioritize elements that have a lower number of zeros over elements that have a higher number of zeros.
This is because a lower number of zeros increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n - el.count(0) / n + el.count(1) / n - el.count(2) / n


def priority_v10(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v9`."""

"""Another improvement could be to prioritize elements that have a lower number of ones over elements that have a higher number of ones.
This is because a lower number of ones increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n - el.count(0) / n - el.count(1) / n + el.count(2) / n


def priority_v11(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v10`."""

"""Another improvement could be to prioritize elements that have a lower number of twos over elements that have a higher number of twos.
This is because a lower number of twos increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n - el.count(0) / n - el.count(1) / n - el.count(2) / n


def priority_v12(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v11`."""

"""Another improvement could be to prioritize elements that have a lower number of zeros and ones over elements that have a lower number of twos.
This is because a lower number of zeros and ones increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n - el.count(0) / n - el.count(1) / n + el.count(2) / n


def priority_v13(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v12`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros and twos over elements that have a higher number of ones.
This is because a higher number of zeros and twos increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n + el.count(0) / n - el.count(1) / n + el.count(2) / n


def priority_v14(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v13`."""

"""Another improvement could be to prioritize elements that have a higher number of ones and twos over elements that have a higher number of zeros.
This is because a higher number of ones and twos increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n - el.count(0) / n + el.count(1) / n + el.count(2) / n


def priority_v15(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v14`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos over elements that have a lower number of zeros, ones, and twos.
This is because a higher number of zeros, ones, and twos increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n + el.count(0) / n + el.count(1) / n + el.count(2) / n


def priority_v16(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v15`."""

"""Another improvement could be to prioritize elements that have a lower number of zeros, ones, and twos over elements that have a higher number of zeros, ones, and twos.
This is because a lower number of zeros, ones, and twos increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n - el.count(0) / n - el.count(1) / n - el.count(2) / n


def priority_v17(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v16`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros and a lower number of ones and twos over elements that have a lower number of zeros and a higher number of ones and twos.
This is because a higher number of zeros and a lower number of ones and twos increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n + el.count(0) / n - el.count(1) / n - el.count(2) / n


def priority_v18(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v17`."""

"""Another improvement could be to prioritize elements that have a higher number of ones and a lower number of zeros and twos over elements that have a lower number of ones and a higher number of zeros and twos.
This is because a higher number of ones and a lower number of zeros and twos increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n - el.count(0) / n + el.count(1) / n - el.count(2) / n


def priority_v19(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v18`."""

"""Another improvement could be to prioritize elements that have a higher number of twos and a lower number of zeros and ones over elements that have a lower number of twos and a higher number of zeros and ones.
This is because a higher number of twos and a lower number of zeros and ones increases the chances of finding a cap set.
"""
return sum(el) / len(set(el)) / (np.std(el) / np.mean(el)) + len(set(el)) / n - el.count(0) / n - el.count(1) / n + el.count(2) / n


def priority_v20(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v19`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the mean of the element over elements that have a higher number of zeros, ones, and twos that are further from the mean of the element.
This is because a higher number of zeros, ones, and twos that are closer to the mean of the element increases the chances of finding a cap set.
"""
mean = np.mean(el)
return sum(el) / len(set(el)) / (np.std(el) / mean) + len(set(el)) / n + abs(el.count(0) - mean) / n - abs(el.count(1) - mean) / n - abs(el.count(2) - mean) / n


def priority_v21(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v20`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the median of the element over elements that have a higher number of zeros, ones, and twos that are further from the median of the element.
This is because a higher number of zeros, ones, and twos that are closer to the median of the element increases the chances of finding a cap set.
"""
median = np.median(el)
return sum(el) / len(set(el)) / (np.std(el) / median) + len(set(el)) / n + abs(el.count(0) - median) / n - abs(el.count(1) - median) / n - abs(el.count(2) - median) / n


def priority_v22(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v21`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the mode of the element over elements that have a higher number of zeros, ones, and twos that are further from the mode of the element.
This is because a higher number of zeros, ones, and twos that are closer to the mode of the element increases the chances of finding a cap set.
"""
mode = max(set(el), key=el.count)
return sum(el) / len(set(el)) / (np.std(el) / mode) + len(set(el)) / n + abs(el.count(0) - mode) / n - abs(el.count(1) - mode) / n - abs(el.count(2) - mode) / n


def priority_v23(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v22`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n


def priority_v24(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v23`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n


def priority_v25(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v24`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n


def priority_v26(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v25`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el)


def priority_v27(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v26`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el)


def priority_v28(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v27`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el)


def priority_v29(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v28`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros


def priority_v30(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v29`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones


def priority_v31(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v30`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos


def priority_v32(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v31`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones


def priority_v33(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v32`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos


def priority_v34(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v33`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos


def priority_v35(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v34`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[1:]) if i < j)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos + runs_of_increasing_order


def priority_v36(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v35`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order and a lower number of runs of zeros, ones, and twos that are in decreasing order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[1:]) if i < j)
runs_of_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos + runs_of_increasing_order + runs_of_decreasing_order


def priority_v37(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v36`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order and a lower number of runs of zeros, ones, and twos that are in decreasing order and a lower number of runs of zeros, ones, and twos that are in alternating order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[1:]) if i < j)
runs_of_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j)
runs_of_alternating_order = sum(1 for i, j in zip(el, el[1:]) if i != j)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos + runs_of_increasing_order + runs_of_decreasing_order + runs_of_alternating_order


def priority_v38(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v37`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order and a lower number of runs of zeros, ones, and twos that are in decreasing order and a lower number of runs of zeros, ones, and twos that are in alternating order and a lower number of runs of zeros, ones, and twos that are in consecutive order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[1:]) if i < j)
runs_of_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j)
runs_of_alternating_order = sum(1 for i, j in zip(el, el[1:]) if i != j)
runs_of_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) == 1)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos + runs_of_increasing_order + runs_of_decreasing_order + runs_of_alternating_order + runs_of_consecutive_order


def priority_v39(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v38`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order and a lower number of runs of zeros, ones, and twos that are in decreasing order and a lower number of runs of zeros, ones, and twos that are in alternating order and a lower number of runs of zeros, ones, and twos that are in consecutive order and a lower number of runs of zeros, ones, and twos that are in non-consecutive order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[1:]) if i < j)
runs_of_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j)
runs_of_alternating_order = sum(1 for i, j in zip(el, el[1:]) if i != j)
runs_of_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) == 1)
runs_of_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) > 1)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos + runs_of_increasing_order + runs_of_decreasing_order + runs_of_alternating_order + runs_of_consecutive_order + runs_of_non_consecutive_order


def priority_v40(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v39`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order and a lower number of runs of zeros, ones, and twos that are in decreasing order and a lower number of runs of zeros, ones, and twos that are in alternating order and a lower number of runs of zeros, ones, and twos that are in consecutive order and a lower number of runs of zeros, ones, and twos that are in non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing order and decreasing order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[1:]) if i < j)
runs_of_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j)
runs_of_alternating_order = sum(1 for i, j in zip(el, el[1:]) if i != j)
runs_of_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) == 1)
runs_of_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) > 1)
runs_of_increasing_and_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j and i - j > 1 or i < j and j - i > 1)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos + runs_of_increasing_order + runs_of_decreasing_order + runs_of_alternating_order + runs_of_consecutive_order + runs_of_non_consecutive_order + runs_of_increasing_and_decreasing_order


def priority_v41(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v40`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order and a lower number of runs of zeros, ones, and twos that are in decreasing order and a lower number of runs of zeros, ones, and twos that are in alternating order and a lower number of runs of zeros, ones, and twos that are in consecutive order and a lower number of runs of zeros, ones, and twos that are in non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[1:]) if i < j)
runs_of_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j)
runs_of_alternating_order = sum(1 for i, j in zip(el, el[1:]) if i != j)
runs_of_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) == 1)
runs_of_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) > 1)
runs_of_increasing_and_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j and i - j > 1 or i < j and j - i > 1)
runs_of_increasing_and_decreasing_order_2 = sum(1 for i, j in zip(el, el[1:]) if i > j or i < j)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos + runs_of_increasing_order + runs_of_decreasing_order + runs_of_alternating_order + runs_of_consecutive_order + runs_of_non_consecutive_order + runs_of_increasing_and_decreasing_order + runs_of_increasing_and_decreasing_order_2


def priority_v42(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v41`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and non-consecutive order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order and a lower number of runs of zeros, ones, and twos that are in decreasing order and a lower number of runs of zeros, ones, and twos that are in alternating order and a lower number of runs of zeros, ones, and twos that are in consecutive order and a lower number of runs of zeros, ones, and twos that are in non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and non-consecutive order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and non-consecutive order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[1:]) if i < j)
runs_of_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j)
runs_of_alternating_order = sum(1 for i, j in zip(el, el[1:]) if i != j)
runs_of_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) == 1)
runs_of_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) > 1)
runs_of_increasing_and_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j and i - j > 1 or i < j and j - i > 1)
runs_of_increasing_and_decreasing_order_2 = sum(1 for i, j in zip(el, el[1:]) if i > j or i < j)
runs_of_increasing_and_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i < j and abs(i - j) > 1)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos + runs_of_increasing_order + runs_of_decreasing_order + runs_of_alternating_order + runs_of_consecutive_order + runs_of_non_consecutive_order + runs_of_increasing_and_decreasing_order + runs_of_increasing_and_decreasing_order_2 + runs_of_increasing_and_non_consecutive_order


def priority_v43(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v42`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and consecutive order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order and a lower number of runs of zeros, ones, and twos that are in decreasing order and a lower number of runs of zeros, ones, and twos that are in alternating order and a lower number of runs of zeros, ones, and twos that are in consecutive order and a lower number of runs of zeros, ones, and twos that are in non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing and consecutive order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and consecutive order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[1:]) if i < j)
runs_of_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j)
runs_of_alternating_order = sum(1 for i, j in zip(el, el[1:]) if i != j)
runs_of_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) == 1)
runs_of_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) > 1)
runs_of_increasing_and_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j and i - j > 1 or i < j and j - i > 1)
runs_of_increasing_and_decreasing_order_2 = sum(1 for i, j in zip(el, el[1:]) if i > j or i < j)
runs_of_increasing_and_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i < j and abs(i - j) > 1)
runs_of_increasing_and_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i < j and abs(i - j) == 1)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos + runs_of_increasing_order + runs_of_decreasing_order + runs_of_alternating_order + runs_of_consecutive_order + runs_of_non_consecutive_order + runs_of_increasing_and_decreasing_order + runs_of_increasing_and_decreasing_order_2 + runs_of_increasing_and_non_consecutive_order + runs_of_increasing_and_consecutive_order


def priority_v44(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v43`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in decreasing and consecutive order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order and a lower number of runs of zeros, ones, and twos that are in decreasing order and a lower number of runs of zeros, ones, and twos that are in alternating order and a lower number of runs of zeros, ones, and twos that are in consecutive order and a lower number of runs of zeros, ones, and twos that are in non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing and consecutive order and a lower number of runs of zeros, ones, and twos that are in decreasing and consecutive order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in decreasing and consecutive order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[1:]) if i < j)
runs_of_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j)
runs_of_alternating_order = sum(1 for i, j in zip(el, el[1:]) if i != j)
runs_of_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) == 1)
runs_of_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) > 1)
runs_of_increasing_and_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j and i - j > 1 or i < j and j - i > 1)
runs_of_increasing_and_decreasing_order_2 = sum(1 for i, j in zip(el, el[1:]) if i > j or i < j)
runs_of_increasing_and_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i < j and abs(i - j) > 1)
runs_of_increasing_and_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i < j and abs(i - j) == 1)
runs_of_decreasing_and_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i > j and abs(i - j) == 1)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos + runs_of_increasing_order + runs_of_decreasing_order + runs_of_alternating_order + runs_of_consecutive_order + runs_of_non_consecutive_order + runs_of_increasing_and_decreasing_order + runs_of_increasing_and_decreasing_order_2 + runs_of_increasing_and_non_consecutive_order + runs_of_increasing_and_consecutive_order + runs_of_decreasing_and_consecutive_order


def priority_v45(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v44`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in decreasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing and consecutive order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order and a lower number of runs of zeros, ones, and twos that are in decreasing order and a lower number of runs of zeros, ones, and twos that are in alternating order and a lower number of runs of zeros, ones, and twos that are in consecutive order and a lower number of runs of zeros, ones, and twos that are in non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing and consecutive order and a lower number of runs of zeros, ones, and twos that are in decreasing and consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing and consecutive order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in decreasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing and consecutive order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[1:]) if i < j)
runs_of_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j)
runs_of_alternating_order = sum(1 for i, j in zip(el, el[1:]) if i != j)
runs_of_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) == 1)
runs_of_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) > 1)
runs_of_increasing_and_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j and i - j > 1 or i < j and j - i > 1)
runs_of_increasing_and_decreasing_order_2 = sum(1 for i, j in zip(el, el[1:]) if i > j or i < j)
runs_of_increasing_and_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i < j and abs(i - j) > 1)
runs_of_increasing_and_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i < j and abs(i - j) == 1)
runs_of_decreasing_and_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i > j and abs(i - j) == 1)
runs_of_increasing_and_decreasing_and_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i > j or i < j and abs(i - j) == 1)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos + runs_of_increasing_order + runs_of_decreasing_order + runs_of_alternating_order + runs_of_consecutive_order + runs_of_non_consecutive_order + runs_of_increasing_and_decreasing_order + runs_of_increasing_and_decreasing_order_2 + runs_of_increasing_and_non_consecutive_order + runs_of_increasing_and_consecutive_order + runs_of_decreasing_and_consecutive_order + runs_of_increasing_and_decreasing_and_consecutive_order


def priority_v46(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v45`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in decreasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing and non-consecutive order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order and a lower number of runs of zeros, ones, and twos that are in decreasing order and a lower number of runs of zeros, ones, and twos that are in alternating order and a lower number of runs of zeros, ones, and twos that are in consecutive order and a lower number of runs of zeros, ones, and twos that are in non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing and consecutive order and a lower number of runs of zeros, ones, and twos that are in decreasing and consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing and consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing and non-consecutive order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in decreasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing and non-consecutive order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[1:]) if i < j)
runs_of_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j)
runs_of_alternating_order = sum(1 for i, j in zip(el, el[1:]) if i != j)
runs_of_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) == 1)
runs_of_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if abs(i - j) > 1)
runs_of_increasing_and_decreasing_order = sum(1 for i, j in zip(el, el[1:]) if i > j and i - j > 1 or i < j and j - i > 1)
runs_of_increasing_and_decreasing_order_2 = sum(1 for i, j in zip(el, el[1:]) if i > j or i < j)
runs_of_increasing_and_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i < j and abs(i - j) > 1)
runs_of_increasing_and_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i < j and abs(i - j) == 1)
runs_of_decreasing_and_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i > j and abs(i - j) == 1)
runs_of_increasing_and_decreasing_and_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i > j or i < j and abs(i - j) == 1)
runs_of_increasing_and_decreasing_and_non_consecutive_order = sum(1 for i, j in zip(el, el[1:]) if i > j or i < j and abs(i - j) > 1)
return sum(el) / len(set(el)) / (np.std(el) / center) + len(set(el)) / n + abs(el.count(0) - center) / n - abs(el.count(1) - center) / n - abs(el.count(2) - center) / n - abs(el.count(0) - center) / n - abs(el.count(1) - center) / n + abs(el.count(2) - center) / n + len(set(el)) / n + sum(el) - np.std(el) + np.std(el) / np.mean(el) + runs_of_zeros + runs_of_ones + runs_of_twos + runs_of_zeros_and_ones + runs_of_zeros_and_twos + runs_of_ones_and_twos + runs_of_increasing_order + runs_of_decreasing_order + runs_of_alternating_order + runs_of_consecutive_order + runs_of_non_consecutive_order + runs_of_increasing_and_decreasing_order + runs_of_increasing_and_decreasing_order_2 + runs_of_increasing_and_non_consecutive_order + runs_of_increasing_and_consecutive_order + runs_of_decreasing_and_consecutive_order + runs_of_increasing_and_decreasing_and_consecutive_order + runs_of_increasing_and_decreasing_and_non_consecutive_order


def priority_v47(el: tuple[int, ...], n: int) -> float:
"""Improved version of `priority_v46`."""

"""Another improvement could be to prioritize elements that have a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in decreasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing and non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing and alternating order over elements that have a higher number of zeros, ones, and twos that are further from the center of the range of the element and a lower number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of unique values and a lower sum of the elements and a higher standard deviation and a lower coefficient of variation and a lower number of runs of zeros and a lower number of runs of ones and a lower number of runs of twos and a lower number of runs of zeros and ones and a lower number of runs of zeros and twos and a lower number of runs of ones and twos and a lower number of runs of zeros, ones, and twos that are in increasing order and a lower number of runs of zeros, ones, and twos that are in decreasing order and a lower number of runs of zeros, ones, and twos that are in alternating order and a lower number of runs of zeros, ones, and twos that are in consecutive order and a lower number of runs of zeros, ones, and twos that are in non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing order and a lower number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing and consecutive order and a lower number of runs of zeros, ones, and twos that are in decreasing and consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing and consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing and non-consecutive order and a lower number of runs of zeros, ones, and twos that are in increasing and decreasing and alternating order.
This is because a higher number of zeros, ones, and twos that are closer to the center of the range of the element and a lower number of zeros, ones, and twos that are further from the center of the range of the element and a higher number of unique values and a higher sum of the elements and a lower standard deviation and a higher coefficient of variation and a higher number of runs of zeros and a higher number of runs of ones and a higher number of runs of twos and a higher number of runs of zeros and ones and a higher number of runs of zeros and twos and a higher number of runs of ones and twos and a higher number of runs of zeros, ones, and twos that are in increasing order and a higher number of runs of zeros, ones, and twos that are in decreasing order and a higher number of runs of zeros, ones, and twos that are in alternating order and a higher number of runs of zeros, ones, and twos that are in consecutive order and a higher number of runs of zeros, ones, and twos that are in non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing order and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing order and a higher number of runs of zeros, ones, and twos that are in increasing and non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in decreasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing and consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing and non-consecutive order and a higher number of runs of zeros, ones, and twos that are in increasing and decreasing and alternating order increases the chances of finding a cap set.
"""
center = (min(el) + max(el)) / 2
runs_of_zeros = sum(1 for i, j in zip(el, el[1:]) if i == j == 0)
runs_of_ones = sum(1 for i, j in zip(el, el[1:]) if i == j == 1)
runs_of_twos = sum(1 for i, j in zip(el, el[1:]) if i == j == 2)
runs_of_zeros_and_ones = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 1})
runs_of_zeros_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {0, 2})
runs_of_ones_and_twos = sum(1 for i, j in zip(el, el[1:]) if i == j and i in {1, 2})
runs_of_increasing_order = sum(1 for i, j in zip(el, el[