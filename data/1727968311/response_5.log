Here's an improved version of `priority_v1` that considers the frequency of each integer in the range `[0, n)` and the distance from `k` to the nearest integer. This version uses the `itertools` library to generate all possible integers in the range and `numpy` for efficient array operations.

```python
import itertools
import numpy as np

@funsearch.run
def priority_v1(k: int, n: int) -> float:
    """Returns the priority with which we want to add `k` to the Salem-Spencer set.
    n is the number of possible integers, and k is the integer we want to determine priority for.
    """
    # Generate all possible integers in the range [0, n)
    integers = np.fromiter(itertools.islice(itertools.count(), n), dtype=int)

    # Calculate the frequency of each integer
    freq = np.bincount(integers, minlength=n)

    # Calculate the distance from k to the nearest integer
    dist = np.abs(integers - k)

    # Calculate the priority as the product of frequency and distance
    priority = np.mean(freq * dist)

    return priority
```

This version of `priority_v1` makes small changes to the previous version by considering the frequency of each integer and the distance from `k` to the nearest integer. The priority is calculated as the mean product of frequency and distance, which should provide a better indication of the importance of adding `k` to the Salem-Spencer set.