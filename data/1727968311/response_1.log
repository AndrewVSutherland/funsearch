Here's an improved version of `priority_v1` that considers the number of unique remainders when dividing `k` by `n`, and the number of multiples of `k` less than `n`. This version is more concise and should provide better results than `priority_v0`.

```python
def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  remainders = set((k * i) % n for i in range(1, n))
  multiples = sum(i for i in range(1, n) if (k * i) % n == 0)
  return len(remainders) + multiples
```

This version uses a set to store unique remainders, which automatically removes duplicates. It then calculates the number of multiples of `k` less than `n` using a generator expression and the `sum` function. The priority is the sum of the number of unique remainders and multiples of `k`.

To further improve the function, you could consider the following aspects:

1. **Weighted remainders**: Not all remainders are equally important. For example, remainders that are close to `n` might be more valuable. You could assign weights to remainders based on their distance from `n`.

2. **Progressive multiples**: Instead of counting all multiples of `k` equally, you could assign more weight to smaller multiples. This can be done by taking the reciprocal of the multiples or using a different weighting function.

Here's an example of incorporating these improvements:

```python
def priority_v2(k: int, n: int) -> float:
  """Further improved version of `priority_v1`."""
  remainders = set((k * i) % n for i in range(1, n))
  multiples = sum(1 / (k * i) for i in range(1, n) if (k * i) % n == 0)
  return len(remainders) + multiples * len(remainders)
```

In this version, the weight of each multiple is inversely proportional to its value, and the total priority is the sum of the number of unique remainders and the weighted sum of multiples, scaled by the number of unique remainders.