Here's an improved version of `priority_v1` that considers the number of unique remainders when dividing `k` by `n`. This is inspired by the Salem-Spencer problem, where the priority is often based on the number of distinct remainders. I've also made the code shorter by using a generator expression instead of a list comprehension.

```python
def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  return len(set(k % i for i in range(1, n + 1)))
```

This version of `priority_v1` calculates the priority as the number of unique remainders when dividing `k` by all integers from 1 to `n`. The `set` function is used to remove duplicates, and `len` returns the count of unique remainders.

To further improve the function, you could consider the following aspects:

1. **Weighted remainders**: Not all remainders might be equally important. You could assign weights to remainders based on some criteria and use the weighted sum instead of the count.

2. **Prime factors**: Consider the prime factorization of `k` and `n`. This might provide additional insights into the priority.

3. **Combinatorial aspects**: Explore combinatorial properties of the remainders or their distribution. For example, you could calculate the number of combinations of remainders that add up to a certain value.

Here's an example of incorporating prime factors into the priority function:

```python
from math import gcd

def priority_v2(k: int, n: int) -> float:
  """Version of `priority_v1` that considers prime factors."""
  return sum(gcd(k, i) for i in range(1, n + 1))
```

In this version, `priority_v2`, the priority is calculated as the sum of the greatest common divisors (gcd) of `k` and all integers from 1 to `n`. This takes into account the prime factors of `k` and `n`.