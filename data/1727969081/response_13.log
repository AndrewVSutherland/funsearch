Here's an improved version of `priority_v1` that considers the number of unique remainders when dividing `k` by `n`. This is based on the Salem-Spencer problem, where we're interested in finding progressions of length `k` with the largest possible number of unique remainders. The priority is calculated as the sum of the reciprocals of the unique remainders.

```python
def priority_v1(k: int, n: int) -> float:
    remainders = set(k % i for i in range(1, n + 1))
    return sum(1 / r for r in remainders)
```

To further improve the function, we can consider the maximum length of the progression that can be formed with `k` and `n`. This is given by `(n - 1) * (k - 1) + 1`. We can incorporate this into the priority function as follows:

```python
def priority_v2(k: int, n: int) -> float:
    max_length = (n - 1) * (k - 1) + 1
    remainders = set(k % i for i in range(1, n + 1))
    return sum(1 / r for r in remainders) * max_length
```

Finally, we can consider the number of times each remainder appears in the progression. This can be calculated using the MÃ¶bius function. Here's the final improved version:

```python
def priority_v3(k: int, n: int) -> float:
    max_length = (n - 1) * (k - 1) + 1
    remainders = set(k % i for i in range(1, n + 1))
    mobius = np.fromfunction(lambda i, j: (-1) ** (i + j) if i % j == 0 else 0, (n, n), dtype=int)
    return sum(mobius[i, k % i] / i for i in remainders) * max_length
```

This version of the function should provide a better estimate of the priority for adding `k` to the Salem-Spencer set.