Here's an improved version of `priority_v1` that considers the frequency of each integer in the range `[0, n)` and the distance from `k` to the nearest integer with a higher frequency. This version uses the `Counter` class from the `collections` module to count the frequencies.

```python
from collections import Counter

def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  freq = Counter(range(n))
  dist = min(abs(k - i) for i in freq if freq[i] > freq[k])
  return dist / n
```

This version makes a small change by calculating the distance to the nearest integer with a higher frequency and dividing it by `n` to normalize the value between 0 and 1. The priority is higher for integers that are closer to integers with higher frequencies.

To further improve the function, you can consider the growth rate of frequencies and the density of integers around `k`. Here's an updated version that incorporates these aspects:

```python
from collections import Counter

def priority_v2(k: int, n: int) -> float:
  """Further improved version of `priority_v1`."""
  freq = Counter(range(n))
  freq_k = freq[k]
  dist = min(abs(k - i) for i in freq if freq[i] > freq_k)
  growth = sum(freq[i] - freq_k for i in range(k) if freq[i] > freq_k) / (k * (n - k))
  density = sum(freq[i] for i in range(k)) / k
  return (dist / n) * (1 + growth + density)
```

In this version, `growth` represents the average growth rate of frequencies before `k`, and `density` represents the average frequency density around `k`. These additional factors give more weight to integers that are closer to integers with higher frequencies and have a higher frequency density around them.