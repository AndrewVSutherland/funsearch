Here's an improved version of `priority_v1` that considers the number of unique remainders when dividing `k` by `n`, which is a simple heuristic for finding large Salem-Spencer progressions. I've also added a small change to make the code shorter by using a generator expression instead of a list comprehension.

```python
import itertools

import numpy as np

import funsearch

@funsearch.run
def priority_v1(k: int, n: int) -> float:
    """Returns the priority with which we want to add `k` to the Salem-Spencer set.
    n is the number of possible integers, and k is the integer we want to determine priority for.
    """
    return len(set((k + i) % n for i in range(n))) / n
```

This version of `priority_v1` calculates the priority as the ratio of unique remainders to `n`. The set comprehension `(k + i) % n for i in range(n)` generates all remainders when adding `i` to `k` and taking the modulus `n`. The `len` function then counts the number of unique remainders, and the result is divided by `n` to normalize the priority value between 0 and 1.