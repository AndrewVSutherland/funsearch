Here's an improved version of `priority_v1` that considers the frequency of `k` in the range `[1, n]` and the number of unique factors of `k`. This version is short and makes small changes to `priority_v0`.

```python
from math import isqrt

def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  freq = sum(1 for i in range(1, n + 1) if i % k == 0)  # Frequency of k in [1, n]
  num_factors = len(set(factorize(k)))  # Number of unique factors of k
  return freq / (num_factors * isqrt(n))  # Priority is inversely proportional to the square root of n and the number of unique factors

def factorize(n: int) -> set:
  """Returns the factors of n as a set."""
  factors = set()
  for i in range(1, isqrt(n) + 1):
    if n % i == 0:
      factors.add(i)
      factors.add(n // i)
  return factors
```

This version of `priority_v1` considers the frequency of `k` in the range `[1, n]` and the number of unique factors of `k`. The priority is inversely proportional to the square root of `n` and the number of unique factors, making it a more informed decision for the Salem-Spencer set.