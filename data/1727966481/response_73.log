Here's an improved version of `priority_v1` that considers the number of unique remainders when dividing by `n` for each integer less than `k`. This is a simple heuristic that prioritizes integers with more unique remainders, as they are more likely to contribute to a large Salem-Spencer progression.

```python
def priority_v1(k: int, n: int) -> float:
    """Improved version of `priority_v0`."""
    remainders = set()
    for i in range(1, k):
        remainders.add(i % n)
    return len(remainders) / n
```

This version of `priority_v1` makes a small change from `priority_v0` by counting the number of unique remainders and dividing it by `n` to normalize the result. This should improve the priority function without making significant changes to the code.

To further improve the function, you could consider additional factors, such as the distribution of remainders or the number of coprime integers less than `k`. However, keep in mind the constraint to make only small changes and keep the code short.