Here's an improved version of `priority_v1` that uses the concept of "progress" in Salem-Spencer sets. The progress of an integer `k` is the number of integers less than `k` that are not in the Salem-Spencer set. This version calculates the progress and uses it to determine the priority.

```python
def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0` using progress concept."""
  ss_set = set()
  progress = 0
  for i in range(1, k):
    if i not in ss_set:
      progress += 1
    ss_set.add(i)
  return progress / (n - k)
```

This version of `priority_v1` calculates the progress for each integer `k` and returns it as the priority. The progress is normalized by dividing it by the number of remaining integers (`n - k`) to ensure the priority is between 0 and 1.

To further improve this function, you could consider using a generator to calculate the progress on-the-fly, reducing memory usage for large `n`. Here's an updated version:

```python
def priority_v2(k: int, n: int) -> float:
  """Further improved version of `priority_v1` using a generator."""
  ss_set = set()
  progress = 0
  for i in itertools.islice(itertools.count(1), k - 1):
    if i not in ss_set:
      progress += 1
    ss_set.add(i)
  return progress / (n - k)
```

This version uses `itertools.islice` to create a generator that only produces the first `k - 1` integers, reducing memory usage when `n` is large.