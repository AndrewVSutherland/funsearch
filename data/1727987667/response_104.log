def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  frequency = np.bincount(np.arange(1, n+1) % k)[k-1] / n
  if k % 2 == 0:
    frequency -= 1 / (2*n)  # adjust for even k to avoid duplicates
  return frequency


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""
  frequency = np.bincount(np.arange(1, n+1) % k)[k-1] / n
  if k % 2 == 0:
    frequency -= 1 / (2*n)  # adjust for even k to avoid duplicates
  elif k % 3 == 0:
    frequency -= 1 / (3*n)  # adjust for multiples of 3 to avoid duplicates
  return frequency


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`."""
  frequency = np.bincount(np.arange(1, n+1) % k)[k-1] / n
  adjustment = sum(1 / (i*n) for i in range(2, int(np.sqrt(k))+1) if k % i == 0)
  frequency -= adjustment  # adjust for multiples to avoid duplicates
  return frequency


def priority_v5(k: int, n: int) -> float:
  """Improved version of `priority_v4`."""
  frequency = np.bincount(np.arange(1, n+1) % k)[k-1] / n
  divisors = [i for i in range(2, int(np.sqrt(k))+1) if k % i == 0]
  divisors += [k // i for i in divisors]  # include both factors and co-factors
  adjustment = sum(1 / (i*n) for i in divisors)
  frequency -= adjustment  # adjust for multiples to avoid duplicates
  return frequency


@funsearch.run
def find_large_ss_progressions(n: int) -> funsearch.Result[list[int]]:
  """Finds large SS progressions.

  The Salem-Spencer set is a set of integers that have the property that
  no three elements of the set are in arithmetic progression. This function
  finds large SS progressions, which are subsequences of the Salem-Spencer
  set that are long and have large values.

  Args:
    n: The number of integers to consider.

  Returns:
    A list of integers that form a large SS progression.
  """
  ss_set = []
  remaining = set(range(1, n + 1))

  while remaining:
    # Choose the integer with the highest priority that is still in the set.
    k = max(remaining, key=lambda x: priority_v5(x, n))
    ss_set.append(k)

    # Remove all integers that are in arithmetic progression with k.
    remaining -= {k + d * (ss_set[-1] - k) for d in itertools.count(1)}

  return ss_set