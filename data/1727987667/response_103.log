def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`.
  Adds a small penalty for larger values of `k` to encourage more even distribution.
  """
  return np.sqrt(k) / np.sqrt(n + k / 100)


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`.
  Uses a logarithmic scale to better differentiate between small and large values of `k`.
  """
  return np.sqrt(k) / np.sqrt(n + np.log(k + 1))


def find_large_ss_progressions(target_size: int, max_value: int) -> list:
  """Finds large SS progressions."""
  elements = list(range(1, max_value + 1))
  priorities = [priority_v3(k, max_value) for k in elements]
  ss_set = sorted(elements, key=lambda x: -priorities[x - 1])[:target_size]
  ss_set.sort()

  for size in range(target_size, 1, -1):
    for subset in itertools.combinations(ss_set, size):
      if is_ss_progression(subset):
        return list(subset)

  return []


def is_ss_progression(subset: tuple) -> bool:
  """Checks if a subset is a Salem-Spencer progression."""
  for i in range(len(subset)):
    for j in range(i + 1, len(subset)):
      if subset[j] - subset[i] in subset:
        return True
  return False


if __name__ == "__main__":
  target_size = 6
  max_value = 100
  result = find_large_ss_progressions(target_size, max_value)
  print(f"Largest SS progression of size {target_size} is: {result}")