"""Improved version of `priority_v1`."""
# Adjust the priority calculation to take into account both the distance from the center and the position within the set
# This could be done by subtracting the current size of the set from the priority calculation

def priority_v2(k: int, n: int, set_size: int) -> float:
    return (k - n/2) / np.sqrt(n) - set_size

def priority_v3(k: int, n: int, set_size: int) -> float:
  """Improved version of `priority_v2`."""
  """Improved version of `priority_v2`."""
  # Introduce a decay factor to prioritize elements closer to the center and lessen the influence of set size as the set grows
  decay_factor = 0.99 ** set_size
  return ((k - n/2) / np.sqrt(n)) * decay_factor

def priority_v4(k: int, n: int, set_size: int) -> float:
  """Improved version of `priority_v3`."""

def find_ss_progression(n: int, min_length: int) -> list:
  """Finds a Salem-Spencer progression of length at least `min_length` in the set {1, ..., n}."""
  ss_set = set()
  for _ in range(n):
    # Add the element with the highest priority to the set
    k = max(range(1, n + 1), key=lambda x: priority_v4(x, n, len(ss_set)))
    ss_set.add(k)
    # Check if the set is a Salem-Spencer progression
    if len(ss_set) >= min_length and all(x + y not in ss_set for x, y in itertools.combinations(ss_set, 2)):
      return sorted(list(ss_set))
  return []

# Example usage:
n = 100
min_length = 10
ss_progression = find_ss_progression(n, min_length)
if ss_progression:
  print(f"Found a Salem-Spencer progression of length {len(ss_progression)}: {ss_progression}")
else:
  print(f"No Salem-Spencer progression of length at least {min_length} found in the set {{1, ..., {n}}}.")