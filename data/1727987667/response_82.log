def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  return k * (n - k) / (n * (n - 1) / 2)


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""
  return k * (n - k) / np.prod(np.arange(1, n - k + 1))


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`."""
  return k * (n - k) / np.prod(np.arange(1, n - k + 1)) * np.log(k)


def priority_v5(k: int, n: int) -> float:
  """Improved version of `priority_v4`."""
  return k * (n - k) / np.prod(np.arange(1, n - k + 1)) * np.log(k) / np.log(n)


def find_large_ss_progressions(n: int, min_length: int, max_length: int) -> list[tuple[int, ...]]:
  """Finds large SS progressions of length `min_length` to `max_length` in the set `{1, ..., n}`.

  Args:
    n: An integer representing the size of the set to search for SS progressions in.
    min_length: An integer representing the minimum length of SS progressions to search for.
    max_length: An integer representing the maximum length of SS progressions to search for.

  Returns:
    A list of tuples representing the SS progressions found. Each tuple contains the
    elements of the SS progression in increasing order.
  """
  ss_progressions = []
  for length in range(min_length, max_length + 1):
    for progression in itertools.combinations(range(1, n + 1), length):
      if all(priority_v5(k, n) > priority_v5(j, n) for j in range(progression[0], progression[-1]) for k in progression if k > j):
        ss_progressions.append(progression)
  return ss_progressions