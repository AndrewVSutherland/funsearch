def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`.

  This version takes into account the number of elements already in the Salem-Spencer set.
  The more elements in the set, the higher the priority for a new element.

  Args:
    k: The integer for which we want to determine priority.
    n: The total number of possible integers.

  Returns:
    The priority for adding `k` to the Salem-Spencer set.
  """
  # Get the current size of the Salem-Spencer set.
  set_size = len(funsearch.get_salem_spencer_set())

  # Calculate the priority as a combination of the integer value and the set size.
  return (k / n) * (set_size + 1)


def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`.

  This version takes into account the average gap between elements in the Salem-Spencer set.
  The larger the average gap, the higher the priority for a new element.

  Args:
    k: The integer for which we want to determine priority.
    n: The total number of possible integers.

  Returns:
    The priority for adding `k` to the Salem-Spencer set.
  """
  # Get the current Salem-Spencer set.
  ss_set = funsearch.get_salem_spencer_set()

  # Calculate the average gap between elements in the set.
  if len(ss_set) < 2:
    avg_gap = 1.0
  else:
    avg_gap = np.mean(np.diff(sorted(ss_set)))

  # Calculate the priority as a combination of the integer value, the set size, and the average gap.
  return (k / n) * (len(ss_set) + 1) * (1.0 / avg_gap)


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`.

  This version takes into account the variance of the gaps between elements in the Salem-Spencer set.
  The larger the variance, the higher the priority for a new element.

  Args:
    k: The integer for which we want to determine priority.
    n: The total number of possible integers.

  Returns:
    The priority for adding `k` to the Salem-Spencer set.
  """
  # Get the current Salem-Spencer set.
  ss_set = funsearch.get_salem_spencer_set()

  # Calculate the average gap between elements in the set.
  if len(ss_set) < 2:
    avg_gap = 1.0
  else:
    avg_gap = np.mean(np.diff(sorted(ss_set)))

  # Calculate the variance of the gaps between elements in the set.
  if len(ss_set) < 3:
    gap_variance = 0.0
  else:
    gap_variance = np.var(np.diff(sorted(ss_set)))

  # Calculate the priority as a combination of the integer value, the set size, the average gap, and the gap variance.
  return (k / n) * (len(ss_set) + 1) * (1.0 / avg_gap) * (1.0 + gap_variance)


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`.

  This version takes into account the order in which elements are added to the Salem-Spencer set.
  The earlier an element is added, the higher its priority.

  Args:
    k: The integer for which we want to determine priority.
    n: The total number of possible integers.

  Returns:
    The priority for adding `k` to the Salem-Spencer set.
  """
  # Get the current Salem-Spencer set.
  ss_set = funsearch.get_salem_spencer_set()

  # Calculate the average gap between elements in the set.
  if len(ss_set) < 2:
    avg_gap = 1.0
  else:
    avg_gap = np.mean(np.diff(sorted(ss_set)))

  # Calculate the variance of the gaps between elements in the set.
  if len(ss_set) < 3:
    gap_variance = 0.0
  else:
    gap_variance = np.var(np.diff(sorted(ss_set)))

  # Calculate the order in which elements are added to the set.
  order = len(ss_set) + 1

  # Calculate the priority as a combination of the integer value, the set size, the average gap, the gap variance, and the order.
  return (k / n) * (len(ss_set) + 1) * (1.0 / avg_gap) * (1.0 + gap_variance) * (1.0 / order)