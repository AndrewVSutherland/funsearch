"""Improved version of `priority_v2`.

We add a small constant to the denominator to avoid division by zero.
This is a common technique to handle zero values in a mathematical expression.
"""
return np.log(k + 1) / (np.log(n + 1) + np.finfo(float).eps)


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""

"""We adjust the calculation to be more sensitive to extreme values.

We use the square root of the ratio instead of the logarithm.
This gives more weight to larger ratios and less weight to smaller ratios, which makes sense as we're interested in large progressions.
"""
return np.sqrt(k + 1) / (np.sqrt(n + 1) + np.finfo(float).eps)


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`."""

"""We use the square of the ratio instead of the square root.

This gives even more weight to larger ratios, which makes sense as we're interested in large progressions.
We also scale the result by a factor of 1/n to normalize the priority values.
"""
return (k + 1)**2 / ((n + 1)**2 + np.finfo(float).eps) / n


def find_large_ss_progressions(max_len: int, max_val: int) -> None:
  """Finds large SS progressions up to `max_len` and `max_val`."""
  for len_ in range(3, max_len + 1):
    # Generate all possible SS progressions of length `len_`
    all_progressions = list(itertools.product(range(1, max_val + 1), repeat=len_))

    # Filter out progressions that are not SS
    ss_progressions = [p for p in all_progressions if np.all(np.diff(p) == p[1] - p[0])]

    # Sort SS progressions by priority
    ss_progressions.sort(key=lambda p: sum(priority_v4(k, max_val) for k in p), reverse=True)

    # Print the top 10 SS progressions
    print(f"Top 10 SS progressions of length {len_}:")
    for i, p in enumerate(ss_progressions[:10]):
      print(f"{i+1}: {p}")
    print()


if __name__ == "__main__":
  find_large_ss_progressions(max_len=5, max_val=10)