"""Improved version of `priority_v0`."""

def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  # Calculate the logarithm of k and n
  log_k = np.log(k)
  log_n = np.log(n)

  # Return the priority as the ratio of the logarithms of k and n
  return log_k / log_n


def generate_candidates(max_size: int, max_value: int) -> list[tuple[int, ...]]:
  """Generates all possible candidates for the Salem-Spencer set."""
  # Generate all possible combinations of integers up to max_value
  combinations = itertools.combinations(range(1, max_value + 1), max_size)

  # Filter the combinations to only include those that satisfy the Salem-Spencer condition
  candidates = [c for c in combinations if all(np.gcd(x, y) == 1 for x, y in itertools.combinations(c, 2))]

  # Return the candidates as a list of tuples
  return candidates


def find_salem_spencer_set(max_size: int, max_value: int) -> tuple[int, ...]:
  """Finds the largest Salem-Spencer set."""
  # Generate all possible candidates for the Salem-Spencer set
  candidates = generate_candidates(max_size, max_value)

  # Sort the candidates by priority, using the improved priority_v1 function
  candidates.sort(key=lambda c: sum(priority_v1(k, max_value) for k in c), reverse=True)

  # Return the first candidate in the sorted list, which will be the largest Salem-Spencer set
  return candidates[0]


# Test the function with max_size = 5 and max_value = 100
print(find_salem_spencer_set(5, 100))