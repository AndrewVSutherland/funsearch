def priority_v2(k: int, n: int) -> float:
    """Improved version of `priority_v1`. Changes the sigmoid formula to put more weight on numbers closer to the center."""
    normalized_k = k / (n / 2) - 1
    return 1 / (1 + np.exp(-10 * (normalized_k - 0.5)))


def priority_v3(k: int, n: int) -> float:
    """Improved version of `priority_v2`. Introduces a penalty for numbers that are too close to the ends of the range."""
    normalized_k = k / (n / 2) - 1
    if normalized_k < 0.1 or normalized_k > 0.9:
        return 0.1 * (1 / (1 + np.exp(-10 * (normalized_k - 0.5))))
    else:
        return 1 / (1 + np.exp(-10 * (normalized_k - 0.5)))


def priority_v4(k: int, n: int) -> float:
    """Improved version of `priority_v3`. Adds a bonus for numbers that are closer to a multiple of n/4."""
    normalized_k = k / (n / 2) - 1
    if normalized_k < 0.1 or normalized_k > 0.9:
        return 0.1 * (1 / (1 + np.exp(-10 * (normalized_k - 0.5))))
    else:
        return 1 / (1 + np.exp(-10 * (normalized_k - 0.5))) + 0.1 * np.cos(2 * np.pi * normalized_k * n / 4)


# ... continue improving the priority function as needed ...

def find_large_ss_progressions(n: int, m: int) -> list[tuple[int, ...]]:
    """Returns a list of Salem-Spencer progressions of length m that have at least one term greater than n/2."""
    # Generate all possible progressions of length m
    progressions = itertools.product(range(1, n + 1), repeat=m)

    # Filter out progressions that don't meet the criteria
    large_ss_progressions = []
    for progression in progressions:
        if all(progression[i] < progression[i + 1] for i in range(m - 1)) and max(progression) > n / 2:
            large_ss_progressions.append(progression)

    # Sort the progressions by priority
    large_ss_progressions.sort(key=lambda x: sum(priority(k, n) for k in x), reverse=True)

    return large_ss_progressions