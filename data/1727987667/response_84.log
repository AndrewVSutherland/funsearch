"""Improved version of `priority_v2`.

In addition to the logarithm of the ratio, we include a bonus for numbers that are close to powers of 2.
This is because numbers close to powers of 2 tend to have more factors, and thus are more likely to be part of a large progression.
"""
return np.log(k + 1) / np.log(n + 1) + np.log(np.abs(np.log2(k + 1) % 1 - 0.5) + 1)


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""

  """Improved version of `priority_v3`.

  In addition to the bonus for numbers close to powers of 2, we also include a penalty for numbers close to powers of 3.
  This is because numbers close to powers of 3 tend to have fewer factors, and thus are less likely to be part of a large progression.
  """
  return (
      np.log(k + 1) / np.log(n + 1)
      + np.log(np.abs(np.log2(k + 1) % 1 - 0.5) + 1)
      - np.log(np.abs(np.log3(k + 1) % 1 - 1 / 3) + 1)
  )


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`."""

  """Improved version of `priority_v4`.

  In addition to the penalties for numbers close to powers of 3, we also include bonuses for numbers close to powers of 5.
  This is because numbers close to powers of 5 tend to have more factors, and thus are more likely to be part of a large progression.
  """
  return (
      np.log(k + 1) / np.log(n + 1)
      + np.log(np.abs(np.log2(k + 1) % 1 - 0.5) + 1)
      - np.log(np.abs(np.log3(k + 1) % 1 - 1 / 3) + 1)
      + np.log(np.abs(np.log5(k + 1) % 1 - 0.5) + 1)
  )


def find_large_ss_progression(max_size: int, max_value: int) -> list[int]:
  """Finds a large Salem-Spencer progression.

  A Salem-Spencer progression is a sequence of integers such that the difference between any two consecutive integers in the sequence is a power of 2.
  For example, (1, 3, 6, 12) is a Salem-Spencer progression, because 3-1 = 2^1, 6-3 = 2^2, and 12-6 = 2^3.

  Args:
    max_size: The maximum size of the Salem-Spencer progression to find.
    max_value: The maximum value of the integers in the Salem-Spencer progression.

  Returns:
    A list of integers representing a large Salem-Spencer progression.
  """
  # Create a list of all possible integers in the range [1, max_value].
  possible_integers = list(range(1, max_value + 1))

  # Initialize an empty list to store the Salem-Spencer progression.
  ss_progression = []

  # Iterate until the Salem-Spencer progression is as large as possible.
  for _ in range(max_size):
    # Calculate the priority of each possible integer.
    priorities = [priority_v4(k, max_value) for k in possible_integers]

    # Choose the integer with the highest priority.
    next_integer = possible_integers[np.argmax(priorities)]

    # Add the integer to the Salem-Spencer progression.
    ss_progression.append(next_integer)

    # Remove the integer from the list of possible integers.
    possible_integers.remove(next_integer)

    # Update the list of possible integers to only include integers that can be added to the Salem-Spencer progression.
    possible_integers = [
        k for k in possible_integers if k >= 2 * ss_progression[-1] - ss_progression[-2]
    ]

  # Return the Salem-Spencer progression.
  return ss_progression


# Find a large Salem-Spencer progression.
ss_progression = find_large_ss_progression(max_size=10, max_value=1000)

# Print the Salem-Spencer progression.
print(ss_progression)
```
The code above defines a function `find_large_ss_progression` that finds a large Salem-Spencer progression. The function takes two arguments: `max_size`, which is the maximum size of the progression to find, and `max_value`, which is the maximum value of the integers in the progression.

The function works by iteratively selecting the integer with the highest priority from a list of possible integers, and adding it to the progression. The priority of an integer is calculated using the `priority_v4` function, which takes into account the ratio of the integer to the maximum value, as well as bonuses and penalties for integers that are close to powers of 2, 3, and 5.

After each iteration, the selected integer is removed from the list of possible integers, and the list is updated to only include integers that can be added to the progression. The iteration continues until the progression is as large as possible.

Finally, the function returns the Salem-Spencer progression. The code then calls this function with `max_size=10` and `max_value=1000`, and prints the resulting progression.