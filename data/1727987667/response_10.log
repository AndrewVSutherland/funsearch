def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  # Priority is inversely proportional to the number of factors of k
  # This is because numbers with fewer factors are more likely to be part of a progression
  return 1.0 / len(list(itertools.chain(*[
      [i, n // i]
      for i in range(1, int(np.sqrt(n)) + 1)
      if n % i == 0
  ])))


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""
  # Priority is also inversely proportional to the number of prime factors of k
  # This is because prime numbers are more likely to be part of a progression
  return 1.0 / (len(list(itertools.chain(*[
      [i, n // i]
      for i in range(1, int(np.sqrt(n)) + 1)
      if n % i == 0
  ]))) * len(funsearch.utils.prime_factors(k)))


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`."""
  # Priority is also proportional to the gap between the previous and current number in the progression
  # This is because larger gaps are more likely to lead to further progressions
  return (1.0 / (len(list(itertools.chain(*[
      [i, n // i]
      for i in range(1, int(np.sqrt(n)) + 1)
      if n % i == 0
  ]))) * len(funsearch.utils.prime_factors(k))) * (k - (funsearch.state.get('prev_num') if funsearch.state.get('prev_num') else 0))


def priority_v5(k: int, n: int) -> float:
  """Improved version of `priority_v4`."""
  # Priority is also proportional to the length of the current progression
  # This is because longer progressions are more likely to be interesting
  return ((1.0 / (len(list(itertools.chain(*[
      [i, n // i]
      for i in range(1, int(np.sqrt(n)) + 1)
      if n % i == 0
  ]))) * len(funsearch.utils.prime_factors(k))) * (k - (funsearch.state.get('prev_num') if funsearch.state.get('prev_num') else 0))) * len(funsearch.state.get('progression') if funsearch.state.get('progression') else [])


# ... continue this pattern to improve the priority function further