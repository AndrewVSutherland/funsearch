Here's an improved version of `priority_v1` that builds upon `priority_v0`. I've made small changes to incorporate the idea of considering the count of unique remainders and their distribution.

```python
def priority_v1(k: int, n: int) -> float:
    """Improved version of `priority_v0`."""
    remainders = set((k + i) % n for i in range(n))
    unique_remainders = len(remainders)
    max_unique = n // 2 + 1  # Maximum unique remainders possible for a given n

    # Add a small penalty for remainders that are not evenly distributed
    distribution_penalty = 0.01 * abs(unique_remainders - max_unique)

    return unique_remainders / n + distribution_penalty
```

In this version, `priority_v1` considers the distribution of unique remainders by comparing the count of unique remainders to the maximum possible count (`n // 2 + 1`). It then adds a small penalty for remainders that are not evenly distributed, encouraging a more balanced distribution.