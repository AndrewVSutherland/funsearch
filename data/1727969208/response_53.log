Here's an improved version of `priority_v1` with a small change to make it more efficient by avoiding the creation of a set and using a counter instead:

```python
from collections import Counter

def priority_v2(k: int, n: int) -> float:
    """Improved version of `priority_v1`."""
    remainders = Counter((k + i) % n for i in range(n))
    return sum(v / n for v in remainders.values()) + 0.01 * (n - sum(remainders.values()))
```

In this version, we use `Counter` to count the occurrences of each remainder, and then calculate the priority as the sum of the ratios of the counts to `n`, plus a small penalty for remainders that don't appear. This should be more efficient than creating a set and then calculating the length, especially for large `n`.