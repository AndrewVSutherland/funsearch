Here's an improved version of `priority_v2` that makes small changes to prioritize elements with higher frequency and lower index:

```python
def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  freq = np.count_nonzero(np.arange(n) == k)
  unique_elements = np.unique(np.arange(n)).size
  return (n - k + 1) * freq / unique_elements  # Add (n - k + 1) to prioritize lower indices
```

Now, let's create a function to find large Salem-Spencer progressions using the `priority_v2` method:

```python
def find_large_ss_progressions(n: int, min_length: int = 3, max_length: int = 6) -> list:
  """Finds large Salem-Spencer progressions of length between min_length and max_length."""
  progressions = []
  for length in range(min_length, max_length + 1):
    for progression in itertools.permutations(range(1, n + 1), length):
      if all(priority_v2(progression[i], n) > priority_v2(progression[i + 1], n) for i in range(length - 1)):
        progressions.append(progression)
  return progressions
```

This function generates all permutations of length `length` in the range `[min_length, max_length]` and checks if the priority of each element is greater than the priority of the next element in the progression. If the condition is satisfied, the progression is added to the list of large Salem-Spencer progressions.