Here's an improved version of `priority_v1` that considers the frequency of `k` in the range `[1, n]` and the number of multiples of `k` within that range. This version is a small change from `priority_v1`, focusing on the count of `k` and its multiples.

```python
def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  count_k = np.count_nonzero(np.arange(1, n + 1) % k == 0)
  return count_k / n
```

To further improve the priority function, we can consider the average distance between multiples of `k` and the number of unique multiples within the range `[1, n]`. Here's `priority_v2` with these considerations:

```python
def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  multiples = np.arange(1, n + 1)[np.arange(1, n + 1) % k == 0]
  count_multiples = len(multiples)
  avg_distance = np.mean(np.diff(multiples))
  return count_multiples * avg_distance / n
```

This version of `priority_v2` gives more weight to numbers with more unique multiples and smaller average distances between them, making it a more informed choice for the Salem-Spencer set.