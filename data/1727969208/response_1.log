Here's an improved version of `priority_v1` that considers the frequency of `k` in the range `[0, n)` and the number of elements already in the Salem-Spencer set. This version uses the formula `priority = frequency / (n * (1 + number_of_elements_in_set))` to calculate the priority.

```python
def priority_v1(k: int, n: int, num_elements_in_set: int) -> float:
    """Improved version of `priority_v0` considering frequency and number of elements in the set."""
    frequency = np.sum(np.arange(n) == k)
    return frequency / (n * (1 + num_elements_in_set))
```

To use this function in your `funsearch` loop, you can pass the `num_elements_in_set` argument and update it on each iteration. Here's an example of how you can modify your `funsearch` loop to use `priority_v1`:

```python
@funsearch.run
def search(n: int, max_iterations: int = 100, initial_k: int = 0):
    num_elements_in_set = 0
    k = initial_k

    for _ in range(max_iterations):
        priority = priority_v1(k, n, num_elements_in_set)
        print(f"Priority for k={k}: {priority:.4f}")

        # Add k to the set and update the number of elements
        num_elements_in_set += 1

        # Find the next k with the highest priority
        k = min(itertools.islice(range(k + 1, n), 1), key=lambda x: priority_v1(x, n, num_elements_in_set))

search(n=100, max_iterations=10)
```