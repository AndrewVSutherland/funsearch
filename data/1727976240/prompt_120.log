"""Finds large SS progressions 

On every iteration, improve priority_v1 over the priority_vX methods from previous iterations.
Make only small changes.
Try to make the code short.
"""
import itertools

import numpy as np

import funsearch


@funsearch.run
def priority_v0(k: int, n: int) -> float:
  """Returns the priority with which we want to add `element` to the salem-spencer set.
  n is the number of possible integers, and k is the integer we want to determine priority for. 
  """
  """Improved version of `priority_v1`."""
  # In order to find large Salem-Spencer progressions, we favor larger numbers
  # and penalize smaller numbers. This is because larger numbers are less likely
  # to be part of a progression, and so we want to prioritize them.

  # We also penalize numbers that are close to multiples of previous numbers in
  # the progression, as these are less likely to lead to a large progression.

  # The priority is calculated as the product of two factors:
  # 1. k / n, which favors larger numbers
  # 2. 1 - (k % (previous number in progression)) / previous number in progression,
  #    which penalizes numbers that are close to multiples of previous numbers.

  # The previous number in the progression is set to the largest number in the
  # progression so far. If there are no numbers in the progression, we default
  # to using 1.

  progression = [k]  # Start with the current number as the only number in the progression
  previous_number = max(progression, default=1)

  return (k / n) * (1 - (k % previous_number) / previous_number)


def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  """Improved version of `priority_v0`."""
  return k / n


def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""

