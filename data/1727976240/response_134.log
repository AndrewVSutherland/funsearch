def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  # If k is divisible by 4, prioritize it even more.
  if k % 4 == 0:
    return (k / n) ** 4
  # Otherwise, use the same logic as priority_v1.
  else:
    return (k / n) ** 3 if k % 2 == 0 else (k / n) ** 2


def large_ss_progressions(max_size: int, max_element: int, min_size: int = 4) -> None:
  """Finds and prints large SS progressions.

  An SS progression is a set of integers, such that every two integers in it
  have a sum that is also in the set.

  Args:
    max_size: The maximum size of SS progressions that we want.
    max_element: The maximum element in SS progressions that we want.
    min_size: The minimum size of SS progressions that we want.
  """
  for size in range(min_size, max_size + 1):
    for element in itertools.permutations(range(1, max_element + 1), size):
      if is_ss_progression(element):
        print(element)


def is_ss_progression(seq: tuple) -> bool:
  """Returns whether `seq` is an SS progression."""
  return all((a + b) in seq for a, b in itertools.combinations(seq, 2))


def main():
  large_ss_progressions(max_size=6, max_element=20)


if __name__ == "__main__":
  main()