def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  # Prioritize larger numbers and numbers close to multiples of n/3 and 2n/3 (triangle symmetry)
  return k / n + min(abs(k - n / 3), abs(k - 2 * n / 3)) / (n / 3)


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""
  # Prioritize larger numbers and numbers close to multiples of n/4, n/2, and 3n/4 (square symmetry)
  return k / n + min(abs(k - n / 4), abs(k - n / 2), abs(k - 3 * n / 4)) / (n / 4)


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`."""
  # Prioritize larger numbers and numbers close to multiples of n/5, 2n/5, 3n/5, and 4n/5 (pentagon symmetry)
  return k / n + min(abs(k - n / 5), abs(k - 2 * n / 5), abs(k - 3 * n / 5), abs(k - 4 * n / 5)) / (n / 5)


def find_largest_ss_progression(max_n: int) -> list:
  """Finds the largest Salem-Spencer progression up to `max_n`."""
  largest_progression = []
  for n in range(2, max_n + 1):
    elements = list(range(1, n + 1))
    ss_progression = []
    while elements:
      # Select the element with the highest priority
      k = max(elements, key=lambda x: priority_v4(x, n))
      ss_progression.append(k)
      elements.remove(k)
      # Remove multiples of k from the list of elements
      elements = [x for x in elements if x % k != 0]
    if len(ss_progression) > len(largest_progression):
      largest_progression = ss_progression
  return largest_progression


def main():
  max_n = 100
  largest_progression = find_largest_ss_progression(max_n)
  print(f"The largest Salem-Spencer progression up to {max_n} is:")
  print(largest_progression)


if __name__ == "__main__":
  main()