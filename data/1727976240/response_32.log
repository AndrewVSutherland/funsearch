"""Improved version of `priority_v1`.

Here, priority is determined by a more sophisticated function that takes into account both the ratio of k to n and the difference between k and the previously selected integer. The idea is to select integers that are both large and far apart from each other.
"""

prev_k = 0

def priority_v2(k: int, n: int) -> float:
  global prev_k
  priority = k / n + (k - prev_k) / n
  prev_k = k
  return priority


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""

  """Improved version of `priority_v2`.

  Here, priority is determined by a function that also takes into account the number of previously selected integers. The idea is to give more priority to integers that are likely to lead to longer sequences of integers with large SS progressions.
  """

  global prev_k
  num_prev_selected = len(funsearch.SalemSpencerSet.current())
  priority = k / n + (k - prev_k) / n - num_prev_selected / n
  prev_k = k
  return priority


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`."""

  """Improved version of `priority_v3`.

  Here, priority is determined by a function that also takes into account the number of remaining possible integers. The idea is to give more priority to integers that are likely to lead to longer sequences of integers with large SS progressions, while also avoiding integers that are unlikely to lead to any valid sequences.
  """

  global prev_k
  num_prev_selected = len(funsearch.SalemSpencerSet.current())
  priority = k / n + (k - prev_k) / n - num_prev_selected / n + (n - num_prev_selected) / n**2
  prev_k = k
  return priority


def priority_v5(k: int, n: int) -> float:
  """Improved version of `priority_v4`."""

  """Improved version of `priority_v4`.

  Here, priority is determined by a function that also takes into account the distribution of the previously selected integers. The idea is to give more priority to integers that are likely to lead to longer sequences of integers with large SS progressions, while also avoiding integers that are unlikely to lead to any valid sequences and avoiding integers that are too close to the previously selected integers.
  """

  global prev_k
  selected_integers = np.array(list(funsearch.SalemSpencerSet.current()))
  priority = k / n + (k - prev_k) / n - len(selected_integers) / n + (n - len(selected_integers)) / n**2
  if len(selected_integers) > 0:
    priority -= np.min(np.abs(k - selected_integers)) / n
  prev_k = k
  return priority