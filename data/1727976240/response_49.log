def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  # Increase the exponent to give more weight to larger k values
  return (k / n) ** 3


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""
  # Introduce a logarithmic term to give more weight to smaller k values
  return (k / n) ** 2 * np.log(k + 1)


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`."""
  # Introduce a normalization term to account for the size of n
  return (k / n) ** 3 * np.log(k + 1) / np.log(n + 1)


def priority_v5(k: int, n: int) -> float:
  """Improved version of `priority_v4`."""
  # Introduce a correction term to account for the distribution of k values
  return (k / n) ** 3 * np.log(k + 1) / np.log(n + 1) / (1 + k / n)


def find_large_ss_progressions(max_length: int) -> list:
  """Finds large SS progressions up to `max_length`."""
  # Define the range of possible integers
  integers = range(1, max_length * 2 + 1)

  # Initialize an empty list to store the results
  results = []

  # Iterate over all possible progression lengths
  for length in range(3, max_length + 1):
    # Generate all possible progressions of the current length
    progressions = itertools.combinations_with_replacement(integers, length)

    # Filter the progressions to only include those that are SS
    ss_progressions = [p for p in progressions if is_ss_progression(p)]

    # Sort the SS progressions by their priority, using the latest version of `priority`
    ss_progressions.sort(key=lambda p: priority_v5(sum(p), len(integers)))

    # Add the highest priority SS progression to the results
    results.append(ss_progressions[-1])

  # Return the results
  return results


def is_ss_progression(progression: tuple) -> bool:
  """Checks if `progression` is an SS progression."""
  # Calculate the sum of the progression
  s = sum(progression)

  # Check if the sum is odd and all elements are odd or all elements are even
  if s % 2 == 1 and all(x % 2 == 1 for x in progression):
    return True
  if s % 2 == 0 and all(x % 2 == 0 for x in progression):
    return True

  # Check if any two elements have a difference that is not divisible by the length of the progression
  for i in range(len(progression)):
    for j in range(i + 1, len(progression)):
      if (progression[j] - progression[i]) % len(progression) != 0:
        return False

  # If all checks pass, the progression is SS
  return True