def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  # Calculate the ratio of k to n
  ratio = k / n

  # Normalize the ratio to be between 0 and 1
  normalized_ratio = ratio / max(k, n)

  # Add a small penalty for larger values of k
  penalty = 1 - (k / (n + 1))

  return normalized_ratio * penalty


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""
  # Calculate the ratio of k to n
  ratio = k / n

  # Normalize the ratio to be between 0 and 1
  normalized_ratio = ratio / max(k, n)

  # Add a small penalty for larger values of k
  penalty = 1 - np.log(k + 1) / np.log(n + 1)

  return normalized_ratio * penalty


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`."""
  # Calculate the ratio of k to n
  ratio = k / n

  # Normalize the ratio to be between 0 and 1
  normalized_ratio = ratio / max(k, n)

  # Add a small penalty for larger values of k
  penalty = 1 - np.sqrt(k) / np.sqrt(n)

  return normalized_ratio * penalty


def find_large_ss_progressions(max_value: int, num_elements: int) -> list[tuple[int, ...]]:
  """Finds large Salem-Spencer progressions."""
  # Generate all possible combinations of integers up to max_value
  combinations = itertools.combinations(range(1, max_value + 1), num_elements)

  # Sort the combinations based on the sum of the elements
  sorted_combinations = sorted(combinations, key=sum)

  # Filter the combinations based on the priority function
  filtered_combinations = [
      combo for combo in sorted_combinations if all(
          priority_v4(i, sum(combo)) > priority_v4(i + 1, sum(combo)) for i in range(len(combo) - 1)
      )
  ]

  return filtered_combinations


# Example usage:
max_value = 20
num_elements = 5
large_ss_progressions = find_large_ss_progressions(max_value, num_elements)
print(large_ss_progressions)