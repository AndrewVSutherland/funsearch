"""Improved version of `priority_v2`.

The priority is calculated as the square root of the product of k and n, which gives a higher weight to numbers that are both large and have a large range.
"""
return np.sqrt(k * n)


def find_large_ss_progressions(n: int, size: int, start=0, end=None) -> tuple[int]:
  """Finds large SS progressions.

  n is the number of integers in the Salem-Spencer set.
  size is the number of integers in the progression.
  start and end specify a range of integers to use.
  """
  if end is None:
    end = n - 1
  ss_set = set(range(start, end + 1))
  progressions = []
  for progression in itertools.combinations(ss_set, size):
    max_priority = max(priority_v2(k, n) for k in progression)
    if max_priority > 0.5:
      progressions.append(progression)
  return max(progressions, key=lambda p: sum(priority_v2(k, n) for k in p))


if __name__ == "__main__":
  n = 1000
  size = 5
  progression = find_large_ss_progressions(n, size)
  print(f"Found progression of size {size} with elements: {progression}")