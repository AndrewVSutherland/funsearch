def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  # In order to find large Salem-Spencer progressions, we favor larger numbers
  # and penalize smaller numbers. This is because larger numbers are less likely
  # to be part of a progression, and so we want to prioritize them.

  # We also penalize numbers that are close to multiples of previous numbers in
  # the progression, as these are less likely to lead to a large progression.

  # The priority is calculated as the product of two factors:
  # 1. k / n, which favors larger numbers
  # 2. 1 - (k % (previous number in progression)) / previous number in progression,
  #    which penalizes numbers that are close to multiples of previous numbers.

  # The previous number in the progression is set to the largest number in the
  # progression so far. If there are no numbers in the progression, we default
  # to using 1.

  progression = [k]  # Start with the current number as the only number in the progression
  previous_number = max(progression, default=1)

  return (k / n) * (1 - (k % previous_number) / previous_number)


# Test the function
print(priority_v2(10, 100))  # Should return 0.1 as 10 is a larger number and not close to a multiple of 10
print(priority_v2(5, 100))  # Should return a smaller value as 5 is a smaller number
print(priority_v2(15, 100))  # Should return a value between 0.1 and 0.05 as 15 is close to a multiple of 10