return float(k / n)


def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""

  return float((k / n) * (1 - (k / n)))


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""

  return float((k / n) * (1 - (k / n)) * np.log(n / k))


def ss_progression(num_elements: int, max_value: int) -> list[int]:
  """Returns a list of `num_elements` distinct integers from the `range(max_value)` such
  that the sum of the largest `i` elements is as close as possible to `i * (i - 1) / 2` times
  the largest element, for all `i` in `range(1, num_elements + 1)`.
  """
  if max_value <= 0 or num_elements <= 0:
    raise ValueError("Both `max_value` and `num_elements` must be positive.")

  if num_elements > max_value:
    raise ValueError("`num_elements` must be less than or equal to `max_value`.")

  ss_set = []

  for _ in range(num_elements):
    priorities = [priority_v3(k, max_value) for k in range(1, max_value + 1)]
    k = np.argmax(priorities) + 1
    ss_set.append(k)
    max_value -= k

  return ss_set


def evaluate_ss_progression(ss_set: list[int]) -> float:
  """Evaluates the quality of a Salem-Spencer progression.
  Returns a value between 0 and 1, where 1 means a perfect progression.
  """
  num_elements = len(ss_set)
  quality = 0

  for i in range(1, num_elements + 1):
    triangular_number = i * (i - 1) / 2
    ss_sum = sum(ss_set[:i])
    quality += 1 - abs(triangular_number - ss_sum / ss_set[i - 1])

  return quality / num_elements


if __name__ == "__main__":
  for num_elements, max_value in itertools.product(range(1, 11), range(1, 21)):
    try:
      ss_set = ss_progression(num_elements, max_value)
      print(
          f"Salem-Spencer progression for {num_elements} elements and max value {max_value}: {ss_set}")
      print(f"Quality: {evaluate_ss_progression(ss_set)}")
    except ValueError as e:
      print(e)
    print()