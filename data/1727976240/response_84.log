"""Improved version of `priority_v1`. Incorporates a penalty for repeating numbers."""
  if k in salem_spencer_set:
    return -1.0
  else:
    return k / n


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`. Considers the gap between the current number and the previous number."""
  if not salem_spencer_set:
    return k / n
  else:
    return (k - max(salem_spencer_set)) / n


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`. Takes into account the total sum of the Salem-Spencer set."""
  if not salem_spencer_set:
    return k / n
  else:
    return (k - max(salem_spencer_set)) / (n - sum(salem_spencer_set))


def find_salem_spencer_progression(n: int) -> list[int]:
  """Finds a Salem-Spencer progression of length n."""
  salem_spencer_set = []
  for _ in range(n):
    # Find the number with the highest priority.
    k = max(range(1, n + 1), key=lambda k: priority_v4(k, n))
    salem_spencer_set.append(k)
  return salem_spencer_set


# Test the function.
print(find_salem_spencer_progression(10))