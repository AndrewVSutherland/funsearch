def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`.

  In this version, we use the logarithm of the ratio to reduce the difference between larger and smaller numbers.
  This allows us to prioritize smaller numbers more effectively.
  """
  # Calculate the ratio of k to n
  ratio = k / n

  # Take the logarithm of the ratio to reduce the difference between larger and smaller numbers
  log_ratio = np.log(ratio) if ratio > 0 else float('-inf')

  # Normalize the logarithm of the ratio to be between 0 and 1
  normalized_log_ratio = log_ratio / np.log(max(k, n)) if max(k, n) > 1 else 0

  return normalized_log_ratio


def priority_v3(k: int, n: int, previous_set: set[int]) -> float:
  """Improved version of `priority_v2`.

  In this version, we consider the size of the intersection between the previous set and the set of divisors of k.
  The larger the intersection, the lower the priority, as this means that k is less diverse compared to the previous set.
  """
  # Calculate the priority using the previous version of the function
  priority = priority_v2(k, n)

  # Calculate the set of divisors of k
  divisors = {i for i in range(1, k + 1) if k % i == 0}

  # Calculate the size of the intersection between the previous set and the set of divisors
  intersection_size = len(previous_set.intersection(divisors))

  # Penalize the priority based on the size of the intersection
  penalty = intersection_size / len(divisors)
  priority *= 1 - penalty

  return priority


def main() -> None:
  # Set the maximum value of n
  max_n = 100

  # Initialize an empty set to store the Salem-Spencer set
  salem_spencer_set = set()

  # Iterate over all possible values of n
  for n in range(1, max_n + 1):
    # Find the k with the highest priority
    k = max(range(1, n + 1), key=lambda x: priority_v3(x, n, salem_spencer_set))

    # Add k to the Salem-Spencer set
    salem_spencer_set.add(k)

  # Print the Salem-Spencer set
  print(sorted(salem_spencer_set))


if __name__ == '__main__':
  main()