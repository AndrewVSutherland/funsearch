Here's an improvement over `priority_v1`. This version takes into account both the size of the number and its distance from the middle of the range. It also adds a small random component to break ties.

```python
import numpy as np

def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  # Prioritize larger numbers and numbers close to half of n (symmetry consideration)
  # Add a small random component to break ties
  return k / n + (1 - abs(k - n / 2) / (n / 2)) + np.random.normal(0, 0.01)
```

In this version, the priority is calculated as the sum of three components:

1. `k / n`: This ensures that larger numbers are prioritized.
2. `(1 - abs(k - n / 2) / (n / 2))`: This favors numbers closer to the middle of the range.
3. `np.random.normal(0, 0.01)`: This adds a small random component to the priority, which helps break ties randomly.

This prioritization strategy aims to find large numbers that are close to the middle of the range, thus potentially leading to large Salem-Spencer progressions.