def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  # Prioritize numbers closer to the middle of the range
  return 1 - abs(k - n / 2) / (n / 2)


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""
  # Prioritize numbers that are more divisors
  return len([i for i in range(1, k + 1) if k % i == 0]) / n


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`."""
  # Prioritize numbers that have fewer prime factors
  factors = [i for i in range(2, k) if k % i == 0]
  primes = [i for i in factors if all(i % j != 0 for j in range(2, i))]
  return 1 / len(primes)


def find_large_ss_progressions(n: int, progression_length: int) -> list[tuple[int]]:
  """Finds large SS progressions.

  Args:
    n: The maximum integer to consider.
    progression_length: The length of the SS progression to find.

  Returns:
    A list of SS progressions of length `progression_length`.
  """
  ss_numbers = []
  for k in range(2, n + 1):
    priority = priority_v4(k, n)
    if k in ss_numbers or np.any(np.diff(ss_numbers + [k]) == 1):
      continue
    ss_numbers.append(k)
    if len(ss_numbers) == progression_length:
      yield tuple(ss_numbers)
      ss_numbers.pop(0)


for progression in itertools.islice(find_large_ss_progressions(1000, 5), 10):
  print(progression)