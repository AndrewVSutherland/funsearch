"""Improved version of `priority_v2`.

The priority is calculated as log(k) / log(n), which gives more weight to larger integers while still ensuring that the priority is within the range [0, 1].
"""
import math

def priority_v2(k: int, n: int) -> float:
    return math.log(k) / math.log(n)


def large_ss_progressions(max_size: int) -> list[tuple[int, ...]]:
    """Returns a list of all large SS progressions of size up to `max_size`."""
    progressions = []
    for size in range(3, max_size + 1):
        for elements in itertools.combinations_with_replacement(range(1, 2 * size + 1), size):
            if np.diff(sorted(elements)).max() > size - 2:
                progressions.append(elements)
    return sorted(progressions, key=lambda x: (len(x), priority_v2(sum(x), len(x))))


def main():
    max_size = 10
    progressions = large_ss_progressions(max_size)
    for progression in progressions:
        print(progression)


if __name__ == '__main__':
    main()