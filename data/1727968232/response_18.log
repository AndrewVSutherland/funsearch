Here's an improved version of `priority_v1` that considers the frequency of `k` in the range `[0, n)` and the average frequency of its neighbors. This version also uses a generator to create the range, which is more memory-efficient for large `n`.

```python
from collections import Counter

def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  freq = Counter(range(k, n)).get(k, 0)
  avg_neighbor_freq = sum(Counter(range(max(0, k-1), min(n, k+2))).values()) / 3.0
  return freq / n + avg_neighbor_freq / n
```

This version makes a small change by considering the frequency of `k` and its neighbors, which might improve the priority calculation. The code is also kept short and follows the given instructions.