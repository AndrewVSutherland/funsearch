Here's an improved version of `priority_v1` that considers the number of 2s and 0s in the input tuple `el`. This version uses the `itertools.product` function to generate all possible tuples of length `n` with values 0-2, and then filters and scores them based on the number of 2s and 0s.

```python
import itertools
import numpy as np

@funsearch.run
def priority_v1(k: int, n: int) -> float:
    """Returns the priority with which we want to add `element` to the cap set.
    el is a tuple of length n with values 0-2.
    """
    # Generate all possible tuples of length n with values 0-2
    elements = list(itertools.product(range(3), repeat=n))

    # Filter tuples with less than k 2s and more than k 0s
    valid_elements = [el for el in elements if sum(x == 2 for x in el) >= k and sum(x == 0 for x in el) <= k]

    # Score tuples based on the number of 2s and 0s
    scores = [sum(x == 2 for x in el) + sum(x == 0 for x in el) for el in valid_elements]

    # Return the maximum score
    return max(scores) if scores else 0.0
```

This version makes small changes to the previous one by filtering out invalid tuples and scoring the remaining ones. It also keeps the code short and follows the given instructions.