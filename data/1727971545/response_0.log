Here's an improved version of `priority_v1` that considers the number of remaining elements and the distance from the current element to the maximum possible integer. This version also uses the `itertools.combinations` function to generate all possible subsets of size `k` from the range `[1, n]`.

```python
import itertools

import numpy as np

import funsearch

@funsearch.run
def priority_v1(k: int, n: int) -> float:
    """Returns the priority with which we want to add `k` to the salem-spencer set.
    n is the number of possible integers, and k is the integer we want to determine priority for.
    """
    # Generate all possible subsets of size k from [1, n]
    subsets = list(itertools.combinations(range(1, n + 1), k))

    # Calculate the priority as the sum of the distances from k to the maximum integer in each subset
    priority = sum(max(sub) - k for sub in subsets)

    # Normalize the priority by the total number of subsets and the maximum possible distance
    return priority / (len(subsets) * (n - k))
```

This version of `priority_v1` makes small changes to the original function by generating all possible subsets of size `k` and calculating the priority as the sum of the distances from `k` to the maximum integer in each subset. The priority is then normalized by the total number of subsets and the maximum possible distance. This should improve the priority function while keeping the changes small and the code short.