Here's an improved version of `priority_v1` that considers the number of unique remainders when dividing other integers by `k`. This metric can help identify large Salem-Spencer progressions.

```python
def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  remainders = {i % k for i in range(1, n + 1)}
  return len(remainders) / (n - 1)
```

This version of `priority_v1` calculates the number of unique remainders when dividing integers from `1` to `n` by `k`. It then divides this count by `n - 1` to normalize the result between `0` and `1`. A higher value indicates a larger potential Salem-Spencer progression, as it suggests that many different progressions can be formed using `k` as a base.

To further improve the function, you can consider additional factors, such as the distribution of remainders or the number of times each remainder appears. Here's a slightly more complex version that takes these factors into account:

```python
def priority_v2(k: int, n: int) -> float:
  """Further improved version of `priority_v1`."""
  remainders = {i % k for i in range(1, n + 1)}
  count = len(remainders)
  max_count = max(remainders.count(r) for r in remainders)
  return count * max_count / (n - 1)
```

In this version, `priority_v2`, we calculate the maximum frequency of any remainder and multiply it by the count of unique remainders. This modification gives more weight to progressions with a higher concentration of remainders, which are more likely to form large Salem-Spencer progressions.