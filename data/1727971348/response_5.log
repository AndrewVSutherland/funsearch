Here's an improved version of `priority_v1` that considers the frequency of each integer in the range `[0, n)` and the distance from `k` to the nearest integer with a higher frequency. This version uses the `Counter` class from the `collections` module to count the frequencies.

```python
from collections import Counter

def priority_v1(k: int, n: int) -> float:
    """Improved version of `priority_v0`."""
    freq = Counter(range(n))
    dist = min(abs(i - k) for i in freq if freq[i] > freq[k])
    return dist / (n - 1)
```

This version makes a small change from `priority_v0` by introducing a simple heuristic to prioritize integers based on their frequency and distance to `k`. The priority is calculated as the ratio of the distance to the nearest integer with a higher frequency to the maximum possible distance (`n - 1`). This should give a higher priority to integers that are close to `k` but have a higher frequency, as they are more likely to be useful in the Salem-Spencer set.

You can further improve this function by considering more factors, such as the frequency of the complement of `k` (i.e., `n - k - 1`), or by using more advanced heuristics or algorithms to estimate the priority. However, keep in mind that making the code too complex might make it harder to understand and maintain.