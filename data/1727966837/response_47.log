Here's an improved version of `priority_v1` that considers the number of unique remainders when dividing `k` by `n`, as well as the frequency of each remainder. This version is more concise and should provide a better priority value.

```python
from collections import Counter

@funsearch.run
def priority_v1(k: int, n: int) -> float:
    """Improved version of `priority_v0`."""
    remainders = [k % i for i in range(1, n + 1)]
    freq = Counter(remainders)
    return len(freq) / n + sum(freq.values()) / (n * len(freq))
```

This version first calculates the remainders of `k` when divided by all integers from 1 to `n`. It then counts the frequency of each remainder using `collections.Counter`. The priority is calculated as the sum of two terms: the ratio of unique remainders to `n`, and the average frequency of remainders. This should provide a better indication of the "largeness" of the Salem-Spencer progression generated by adding `k` to the set.