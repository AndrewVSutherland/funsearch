Here's an improved version of `priority_v1` that considers the number of unique remainders when dividing `k` by `n`. This is inspired by the Salem-Spencer problem, where the goal is to find progressions with large gaps. The priority is now calculated as the sum of the reciprocals of the remainders, which should be larger for progressions with larger gaps.

```python
def priority_v1(k: int, n: int) -> float:
    """Improved version of `priority_v0`."""
    remainders = set(i % n for i in range(k, k + n))
    return sum(1 / r for r in remainders if r != 0)
```

To make the code even shorter, you can use a generator expression instead of a set comprehension:

```python
def priority_v1(k: int, n: int) -> float:
    """Improved version of `priority_v0`."""
    return sum(1 / r for r in (i % n for i in range(k, k + n)) if r != 0)
```

This version of `priority_v1` should perform better than `priority_v0` in finding large Salem-Spencer progressions. To further improve the function, you could consider additional factors, such as the distribution of remainders or the number of common divisors between `k` and `n`. However, keep in mind that making the function too complex might make it harder to understand and maintain.