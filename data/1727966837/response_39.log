Here's an improved version of `priority_v1` that considers the number of unique remainders when dividing `k` by `n` and the number of multiples of `k` less than `n`. This version is shorter and only makes small changes to `priority_v0`.

```python
def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  remainders = set(k % i for i in range(1, n))
  multiples = sum(i for i in range(1, n) if i % k == 0)
  return len(remainders) + multiples
```

This version uses a set to store unique remainders, which automatically removes duplicates. It then calculates the number of multiples of `k` less than `n` using a generator expression and the `sum` function. The priority is the sum of the number of unique remainders and multiples of `k`.

To further improve the function, you could consider the following changes for `priority_v2`:

```python
def priority_v2(k: int, n: int) -> float:
  """Further improved version of `priority_v1`."""
  remainders = len(set(k % i for i in range(1, n)))
  multiples = sum(i for i in range(1, min(k, n)) if i % k == 0)
  return remainders + multiples + (n // k if k > 0 else 0)
```

In this version, I've added an additional term `(n // k if k > 0 else 0)` to account for the number of times `k` can divide `n` without a remainder. This term is only added if `k` is positive to avoid division by zero. I've also changed the range for the multiples calculation to `range(1, min(k, n))` to avoid calculating multiples that are greater than `n`.