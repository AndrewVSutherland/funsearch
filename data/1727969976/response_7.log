Here is a possible solution for this problem. In this solution, I have improved the priority function to consider the size of the gap between numbers already in the Salem-Spencer set and the new number to be added:

```python
def priority_v1(k: int, n: int, ss_set: set) -> float:
    """Improved version of `priority_v0`."""
    if not ss_set:
        return float('inf')
    return max(abs(k - x) for x in ss_set)
```

In this function, `ss_set` is the current Salem-Spencer set. The function returns the maximum gap between the number `k` and any number in the set `ss_set`. This means that numbers that are far from any number in the set will have a higher priority.

This function can be used to select the next number to add to the Salem-Spencer set in a greedy manner. This will tend to result in sets where the numbers are as far apart as possible, which is desirable for many applications.

However, this function does not consider the total number of possible integers `n`. If you want to include `n` in the priority calculation, you could modify the function like this:

```python
def priority_v1(k: int, n: int, ss_set: set) -> float:
    """Improved version of `priority_v0`."""
    if not ss_set:
        return float('inf')
    gap_priority = max(abs(k - x) for x in ss_set)
    size_priority = n / len(ss_set)  # favor smaller sets
    return gap_priority * size_priority
```

In this version of the function, `size_priority` is a measure of the "density" of the set. It is inversely proportional to the size of the set, so smaller sets will have a higher priority. The product of `gap_priority` and `size_priority` is then returned as the total priority.