def priority_v1(k: int, n: int) -> float:
  """Improved version of `priority_v0`."""
  # Add a small adjustment to the priority to favor larger numbers
  return k / n + 0.01 * k / n**2


@funsearch.run
def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`."""
  # Introduce a logarithmic factor to further favor larger numbers
  return k / n + 0.01 * k / n**2 + 0.001 * np.log(k) / np.log(n)


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""
  # Add a penalty for smaller numbers to balance out the larger numbers
  return k / n + 0.01 * k / n**2 + 0.001 * np.log(k) / np.log(n) - 0.001 * np.log(n - k) / np.log(n)


def generate_candidates(n: int, k: int) -> list[int]:
  """Generates a list of candidate integers for the Salem-Spencer set."""
  # Generate a list of all integers from 1 to n
  candidates = list(range(1, n + 1))
  # Sort the candidates based on their priority
  candidates.sort(key=lambda x: priority_v3(x, n), reverse=True)
  # Return the top k candidates
  return candidates[:k]


def find_large_ss_progressions(n: int, k: int, length: int) -> list[tuple[int, ...]]:
  """Finds large Salem-Spencer progressions."""
  # Generate a list of candidate integers for the Salem-Spencer set
  candidates = generate_candidates(n, k)
  # Generate all possible progressions of length `length` from the candidates
  progressions = list(itertools.product(candidates, repeat=length))
  # Filter out the progressions that are not Salem-Spencer progressions
  ss_progressions = [p for p in progressions if all(p[i] + p[j] == p[k] for i, j, k in itertools.combinations(range(length), 3))]
  # Return the Salem-Spencer progressions sorted by their maximum element
  return sorted(ss_progressions, key=max, reverse=True)