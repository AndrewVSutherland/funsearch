"""Prioritizes larger numbers and normalizes the priority value.
Also, penalizes numbers that are close to other numbers already in the set."""
return float(k) / n - sum(abs(k - x) for x in current_set) / (n * len(current_set))


@funsearch.run
def priority_v2(k: int, n: int, current_set: set) -> float:
  """Improved version of `priority_v1`."""

  """Considers the distance between the k-th number and the existing numbers in the set.
Instead of just subtracting the sum of absolute differences, it squares them,
which gives more weight to larger differences."""
return float(k) / n - sum((k - x) ** 2 for x in current_set) / (n ** 2 * len(current_set))


@funsearch.run
def priority_v3(k: int, n: int, current_set: set) -> float:
  """Improved version of `priority_v2`."""

  """Considers not only the distance to existing numbers but also the distance
between the k-th number and the gaps between existing numbers.
This helps to avoid adding numbers that are too close to each other."""
dist_to_existing = sum((k - x) ** 2 for x in current_set)
dist_to_gaps = sum((x - y) ** 2 for x, y in itertools.combinations(current_set, 2))
return float(k) / n - (dist_to_existing + dist_to_gaps) / (n ** 2 * len(current_set) ** 2)


@funsearch.run
def salem_spencer_set(n: int, size: int, priority_fn: callable) -> set:
  """Returns the Salem-Spencer set of the first `size` numbers in [1, `n`]."""
  return set(sorted(range(1, n + 1), key=lambda k: priority_fn(k, n, set()), reverse=True)[:size])


def optimize_salem_spencer_set(n: int, size: int) -> set:
  """Returns the optimal Salem-Spencer set of the first `size` numbers in [1, `n`]."""
  return salem_spencer_set(n, size, priority_v3)


# Example usage
n = 100
size = 10
print(optimize_salem_spencer_set(n, size))