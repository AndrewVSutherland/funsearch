def priority_v2(k: int, n: int) -> float:
  """Improved version of `priority_v1`. Considers both the value of k and its position among available integers."""
  return (k ** 2) / n


def find_large_ss_progressions(max_number: int, ss_set_size: int = 20) -> list[set[int]]:
  """Finds Salem-Spencer sets of a given size with a large sum.
  Args:
    max_number: The maximum number to consider for the Salem-Spencer sets.
    ss_set_size: The size of the Salem-Spencer sets to find.
  Returns:
    A list of Salem-Spencer sets that have a large sum.
  """
  ss_sets = []
  numbers = list(range(1, max_number + 1))
  for ss_set in itertools.combinations(numbers, ss_set_size):
    ss_sum = sum(ss_set)
    if ss_sum > (max_number * ss_set_size) / 2:  # If the sum is larger than half of the maximum possible sum
      ss_sets.append(set(ss_set))
  return ss_sets


def find_optimal_ss_sets(max_number: int, ss_set_size: int = 20) -> list[set[int]]:
  """Finds optimal Salem-Spencer sets of a given size.
  Args:
    max_number: The maximum number to consider for the Salem-Spencer sets.
    ss_set_size: The size of the Salem-Spencer sets to find.
  Returns:
    A list of optimal Salem-Spencer sets.
  """
  ss_sets = []
  numbers = list(range(1, max_number + 1))
  for ss_set in itertools.combinations(numbers, ss_set_size):
    priority_sum = sum(priority_v2(k, max_number) for k in ss_set)
    if len(ss_sets) < 10 or priority_sum > min(s["priority_sum"] for s in ss_sets):
      ss_sets.append({"set": set(ss_set), "priority_sum": priority_sum})
      if len(ss_sets) > 10:
        ss_sets.remove(min(ss_sets, key=lambda s: s["priority_sum"]))
  return [s["set"] for s in ss_sets]