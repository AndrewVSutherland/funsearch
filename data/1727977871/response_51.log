"""Final version of `priority_vX`."""
return k ** 1.0001 / n ** 1.0001


def priority_v3(k: int, n: int) -> float:
  """Improved version of `priority_v2`."""

  """Final version of `priority_vX`."""
  return k ** 1.0001 / n ** 1.0001 + np.log(k) / np.log(n)


def priority_v4(k: int, n: int) -> float:
  """Improved version of `priority_v3`."""

  """Final version of `priority_vX`."""
  return k ** 1.0001 / n ** 1.0001 + np.log(k) / np.log(n) + np.sqrt(k) / np.sqrt(n)


def priority_v5(k: int, n: int) -> float:
  """Improved version of `priority_v4`."""

  """Final version of `priority_vX`."""
  return (k ** 1.0001 / n ** 1.0001 + np.log(k) / np.log(n) +
          np.sqrt(k) / np.sqrt(n) + k / n ** 1.0001)


def salem_spencer_progression(n: int, m: int, priority: callable) -> list[list[int]]:
  """Returns the salem-spencer progression of length `n` with `m` possible integers."""
  salem_spencer_sets = []
  possible_integers = list(range(1, m + 1))

  while len(salem_spencer_sets) < n:
    priorities = [priority(k, m) for k in possible_integers]
    max_priority_index = np.argmax(priorities)
    max_priority = possible_integers.pop(max_priority_index)
    salem_spencer_sets.append(max_priority)

    # Update priorities for remaining possible integers
    possible_integers = [k - max_priority for k in possible_integers if k > max_priority]

  return salem_spencer_sets


def main():
  n = 10
  m = 1000
  priority = priority_v5

  salem_spencer_sets = salem_spencer_progression(n, m, priority)
  print(f"The Salem-Spencer progression of length {n} with {m} possible integers is:")
  print(salem_spencer_sets)


if __name__ == "__main__":
  main()